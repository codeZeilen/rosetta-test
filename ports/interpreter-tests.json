[
    {"input": "(quote (testing 1 (2.0) -3.14e159))", "expected": ["testing", 1, [2.0], -3.14e159]},
    {"input": "(+ 2 2)", "expected": 4},
    {"input": "(+ (* 2 100) (* 1 10))", "expected": 210},
    {"input": "(if (> 6 5) (+ 1 1) (+ 2 2))", "expected": 2},
    {"input": "(if (< 6 5) (+ 1 1) (+ 2 2))", "expected": 4},
    {"input": "(cond ((< 6 5) 1) ((< 5 6) 2) (else 3) )", "expected": 2},
    {"input": "(cond ((< 6 5) 1) (#f 2) (else 3) )", "expected": 3},
    {"input": "(cond ((< 6 5) 1) (#f 2))", "expected": null},
    {"input": "(define x 3)", "expected": null},
    {"input": "x", "expected": 3}, 
    {"input": "(+ x x)", "expected": 6},
    {"input": "((lambda (x) (+ x x)) 5)", "expected": 10},
    {"input": "(define twice (lambda (x) (* 2 x)))", "expected": null}, 
    {"input": "(twice 5)", "expected": 10},
    {"input": "(define compose (lambda (f g) (lambda (x) (f (g x)))))", "expected": null},
    {"input": "((compose list twice) 5)", "expected": [10]},
    {"input": "(define repeat (lambda (f) (compose f f)))", "expected": null},
    {"input": "((repeat twice) 5)", "expected": 20}, 
    {"input": "((repeat (repeat twice)) 5)", "expected": 80},
    {"input": "(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))", "expected": null},
    {"input": "(fact 3)", "expected": 6},
    {"input": "(fact 50)", "expected": 30414093201713378043612608166064768844377641568960512000000000000},
    {"input": "(define abs (lambda (n) ((if (> n 0) + -) 0 n)))", "expected": null},
    {"input": "(list (abs -3) (abs 0) (abs 3))", "expected": [3, 0, 3]},
    {"input": "(define combine (lambda (f)\n(lambda (x y)\n(if (null? x) (quote ())\n(f (list (car x) (car y))\n((combine f) (cdr x) (cdr y)))))))", "expected": null},
    {"input": "(define zip (combine cons))", "expected": null},
    {"input": "(zip (list 1 2 3 4) (list 5 6 7 8))", "expected" : [[1, 5], [2, 6], [3, 7], [4, 8]]},
    {"input": "(define riff-shuffle (lambda (deck) (begin\n(define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq))))))\n(define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq)))))\n(define mid (lambda (seq) (/ (length seq) 2)))\n((combine append) (take (mid deck) deck) (drop (mid deck) deck)))))", "expected" : null},
    {"input": "(riff-shuffle (list 1 2 3 4 5 6 7 8))", "expected" : [1, 5, 2, 6, 3, 7, 4, 8]},
    {"input": "((repeat riff-shuffle) (list 1 2 3 4 5 6 7 8))",  "expected" : [1, 3, 5, 7, 2, 4, 6, 8]},
    {"input": "(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))", "expected" : [1,2,3,4,5,6,7,8]},
    {"input": "(equal? \"a\" 'a)", "expected": false},
    {"input": "(equal? 'a \"a\")", "expected": false},
    {"input": "(equal? \"a\" \"a\")", "expected": true},
    {"input": "(equal? 'a 'a)", "expected": true},
    {"input": "(eq? 'a 'a)", "expected": true},
    {"input": "(eqv? 'a 'a)", "expected": true},
    {"input": "()", "expected":  {"type": "SyntaxError"}},
    {"input": "(set! x)", "expected":  {"type": "SyntaxError"}},
    {"input": "(define 3 4)", "expected":  {"type": "SyntaxError"}},
    {"input": "(quote 1 2)", "expected":  {"type": "SyntaxError"}},
    {"input": "(if 1 2 3 4)", "expected":  {"type": "SyntaxError"}},
    {"input": "(lambda 3 3)", "expected":  {"type": "SyntaxError"}},
    {"input": "(lambda (x))", "expected":  {"type": "SyntaxError"}},
    {"input": "(if (= 1 2) (define-macro a 'a)\n(define-macro a 'b))", "expected": {"type": "SyntaxError"}},
    {"input": "(define (twice x) (* 2 x))", "expected": null},
    {"input": "(twice 2)", "expected": 4},
    {"input": "(twice 2 2)", "expected": {"type": "TypeError"}},
    {"input": "(define lyst (lambda items items))", "expected": null},
    {"input": "(lyst 1 2 3 (+ 2 2))", "expected": [1,2,3,4]},
    {"input": "(if 1 2)", "expected": 2},
    {"input": "(if (= 3 4) 2)", "expected": null},
    {"input": "(begin (define x 1) (set! x (+ x 1)) (+ x 1))", "expected": 3},
    {"input": "(define (newton guess function derivative epsilon)\n(define guess2 (- guess (/ (function guess) (derivative guess))))\n(if (< (abs (- guess guess2)) epsilon) guess2\n(newton guess2 function derivative epsilon)))", "expected": null},
    {"input": "(define (square-root a)\n(newton 1 (lambda (x) (- (* x x) a)) (lambda (x) (* 2 x)) 1e-8))", "expected": null},
    {"input": "(> (square-root 200.) 14.14213)", "expected": true},
    {"input": "(< (square-root 200.) 14.14215)", "expected": true},
    {"input": "(define (sum-squares-range start end)\n(define (sumsq-acc start end acc)\n(if (> start end) acc (sumsq-acc (+ start 1) end (+ (* start start) acc))))\n(sumsq-acc start end 0))", "expected": null},
    {"input": "(sum-squares-range 1 3000)", "expected": 9004500500},
    {"input": "(let ((a 1) (b 2)) (+ a b))", "expected": 3},
    {"input": "(let ((a 1) (b 2 3)) (+ a b))", "expected": {"type": "SyntaxError"}},
    {"input": "(and 1 2 3)", "expected": 3}, 
    {"input": "(and (> 2 1) 2 3)", "expected": 3}, 
    {"input": "(and)", "expected": true},
    {"input": "(and (> 2 1) (> 2 3))", "expected": false},
    {"input": "(xor)", "expected": false},
    {"input": "(xor #t #t)", "expected": false},
    {"input": "(xor #f #t)", "expected": true},
    {"input": "(xor #t #f)", "expected": true},
    {"input": "(xor #f #f)", "expected": false},
    {"input": "(define-macro unless (lambda args `(if (not ,(car args)) (begin ,@(cdr args))))) ; test `", "expected": null},
    {"input": "(unless (= 2 (+ 1 1)) (display 2) 3 4)", "expected": null},
    {"input": "(unless (= 4 (+ 1 1)) (display 2) (display \"\\n\") 3 4)", "expected": 4},
    {"input": "(quote x)", "expected": "x"},
    {"input": "(quote (1 2 three))", "expected": [1, 2, "three"]},
    {"input": "'x", "expected": "x"},
    {"input": "'(one 2 3)", "expected": ["one", 2, 3]},
    {"input": "(define L (list 1 2 3))", "expected": null},
    {"input": "`(testing ,@L testing)", "expected": ["testing", 1,2,3, "testing"]},
    {"input": "`(testing ,L testing)", "expected": ["testing", [1,2,3], "testing"]},
    {"input": "`,@L", "expected": {"type": "SyntaxError"}},
    {"input": "'(1 ;test comments '\n;skip this line\n2 ; more ; comments ; ) )\n3) ; final comment", "expected": [1,2,3]},
    {"input": "(define al (alist 1 2 'a 3))", "expected": null},
    {"input": "(assq 'a al)", "expected": ["a", 3]},
    {"input": "(assq 1 al)", "expected": [1, 2]},
    {"input": "(assq 'b al)", "expected": false},
    {"input": "(assv 'a al)", "expected": ["a", 3]},
    {"input": "(assv 1 al)", "expected": [1, 2]},
    {"input": "(assv 'b al)", "expected": false},
    {"input": "(assoc 'a al)", "expected": ["a", 3]},
    {"input": "(assoc 1 al)", "expected": [1, 2]},
    {"input": "(assoc 'b al)", "expected": false},
    {"input": "(assoc 'b (alist-cons 'b 10 al))", "expected": ["b", 10]},
    {"input": "(assoc 'a (alist-delete 'a al))", "expected": false},
    {"input": "(hash-table? (make-hash-table))", "expected": true},
    {"input": "(hash-table? (list))", "expected": false},
    {"input": "(define ht (make-hash-table))", "expected": null},
    {"input": "(hash-table-set! ht 'a 1)", "expected": null},
    {"input": "(hash-table-set! ht 'b 2)", "expected": null},
    {"input": "(hash-table-ref ht 'a)", "expected": 1},
    {"input": "(hash-table-ref ht 'c 3)", "expected": 3},
    {"input": "(hash-table-ref ht 'c)", "expected": {"type": "Error"}},
    {"input": "(hash-table-keys ht)", "expected": ["a", "b"]},
    {"input": "(hash-table-keys (make-hash-table))", "expected": []},
    {"input": "(hash-table-values ht)", "expected": [1, 2]},
    {"input": "(hash-table-values (make-hash-table))", "expected": []},
    {"input": "(hash-table-delete! ht 'a)", "expected": null},
    {"input": "(hash-table-ref ht 'a)", "expected": {"type": "Error"}},
    {"input": "(hash-table-delete! ht 'a) ; second delete is not a problem", "expected": null},
    {"input": "(hash-table-size ht)", "expected": 1},
    {"input": "(hash-table-exists? ht 'a)", "expected": false},
    {"input": "(hash-table-exists? ht 'b)", "expected": true},
    {"input": "(hash-table-map ht (lambda (key value) key))", "expected": ["b"]},
    {"input": "(hash-table-walk ht (lambda (key value) key))", "expected": null},
    {"input": "(begin (hash-table-ref! ht 'c 3) (hash-table-ref ht 'c))", "expected": 3}
]