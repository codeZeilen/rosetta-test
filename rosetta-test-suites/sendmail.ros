(suite 
	"sendmail" "0.1"
    ; The scope of this test suite are APIs that allow users to send email easily without having
    ; to deal with the details of a transport protocol. This includes constructing the email message itself
    ; indepdenent of whether this is done with an API from the tested library directly or by using 
    ; another library, e.g. a MIME library from the standard library.
    (sources 
		'("Ruby mail gem spec" "Mikel Lindsaar" "https://github.com/mikel/mail") 
        '("SMTP RFC 2821" "IETF" "https://tools.ietf.org/html/rfc2821")
        '("SMTP RFC 5321" "IETF" "https://tools.ietf.org/html/rfc5321")
        '("RFC 2183 - Content-Disposition" "IETF" "https://tools.ietf.org/html/rfc2183"))
    
    (list 
        ; Socket
        (placeholder '(create-socket) "Create a local network socket for the server to communicate through (it should already listen for new connections)")
        (placeholder '(socket-receive socket) "Read trimmed data from socket")
        (placeholder '(socket-write socket data) "Write data to socket")
        (placeholder '(socket-port socket) "Return the port of the socket")
        (placeholder '(socket-accept socket) "Accept a new connection on the socket")
        (placeholder '(socket-close socket) "Close the socket")
        (placeholder '(secure-server-socket-wrap socket ca-file cert-file key-file close-underlying-socket) "Should wrap an existing connected server socket with a secure socket (TLS/SSL) with the given configuration. Then the procedure should wait for the handshake (accept) to complete.")

        ; SMTP connection
        (placeholder '(sendmail-connect host port) "Should connect and return some representation of the connection.")
        (placeholder '(sendmail-connect-with-credentials host port user password) "Should connect and return some representation of the connection. The credentials should be used to authenticate the connection.")
        (placeholder '(sendmail-disconnect connection) "Should close the connection")
        (placeholder '(sendmail-connected? connection) "Should return true if the connection is still open")
        
        ; Send Mail
        (placeholder '(sendmail-send-message-full connection message-content from to-list cc-list bcc-list headers attachments message-options to-list-options) "Send a message to the server. The cc-list and bcc-list are optional. The headers hash is optional. The message-options and the to-list-options are optional. The to-list-options is a list of option tuple lists, one for each receiver. The function should return a list corresponding to the responses from the server for each recipient in the to-list. If there is only a single response, a list with a single response should be returned.")
         
        (define (sendmail-send-message-with-options connection message-content from to-list message-options to-list-options) 
            (sendmail-send-message-full connection message-content from to-list '() '() (make-hash-table) (make-hash-table) message-options to-list-options))
        (define (sendmail-send-message connection content from to-list)
            (sendmail-send-message-with-options connection content from to-list  '() '()))
        (define (sendmail-send-message-with-headers connection content from to-list headers-hash-map)
            (sendmail-send-message-full connection content from to-list '() '() headers-hash-map (make-hash-table) '() '()))
        
        ; Response accessors
        (placeholder '(send-success? response) "Return whether the sending was successful.")
        (placeholder '(send-error? response) "Returns true if the sending resulted in an error of some kind. This includes error responses from the server as well as errors in the client-server communication.")

        (include "rosetta-test-suites/smtp-mock-server.scm")

        ; Compile one option to a string, either from a tuple (KEY VALUE|VALUES) to "KEY=VALUE,VALUE"
        ; or if already a string, simply return it.
        (define (compile-option-string option)
            (if (list? option)
                (string-append 
                    (first option)
                    "="
                    (if (list? (last option)) 
                        (string-join (last option) ",") 
                        (last option)))
                ; If not a list, just retrun
                option))

        ; Compile a list of option tuples to a list of strings
        (define (compile-options-strings options) 
            (map compile-option-string options))

        ; Compile a list of option strings to a single string that can be sent to the server
        (define (compile-options-string options) 
            (string-join (compile-options-strings options) " "))

        (define (server-message-contains? content)
                (string-contains? (server-message-data server) content))

        (define (server-message-contains-ci? content)
                (string-contains-ci? (server-message-data server) content))

        (setup (lambda ()  
            (set! server '())))

        (tearDown (lambda () 
            (stop-mock-server)))

        ;
        ; Capabilities
        ;

        (capability 'connection (list

            (define sendmail-connection '())

            (setup (lambda ()
                (set! server (start-mock-server))
                (server-set-extensions! server '("STARTTLS"))
                (server-set-auths! server '(("LOGIN" ("account" "password"))))
                (define (login-auth-proc credentials connection success failure)
                    (let 
                        ((login-user-response
                            (if (not (= credentials "")) 
                                credentials
                                (begin
                                    (socket-write connection "334 VXNlcm5hbWU6\r\n")
                                    (string-trim (socket-receive connection))))))
                        (socket-write connection "334 UGFzc3dvcmQ6\r\n")
                        (let 
                            ((login-password-response (string-trim (socket-receive connection)))) 
                            (if (and (= login-user-response "YWNjb3VudA==") (= login-password-response "cGFzc3dvcmQ="))
                                (success)
                                (failure)))))
                (server-set-auth-proc! server login-auth-proc)))

            (tearDown (lambda ()
                (sendmail-disconnect sendmail-connection)
                (set! sendmail-connection '())))

            (capability 'eager-connection (list
                (test "Connect to server" (lambda () 
                    (set! sendmail-connection (sendmail-connect "localhost" (server-port server)))
                    (assert (sendmail-connected? sendmail-connection))))

                (test "Connect with non-numeric port is an error" (lambda ()
                    (assert (send-error? (sendmail-connect "localhost" "not-a-port")))
                    (sendmail-connect "localhost" (server-port server)))) ; Give the mock server a chance to terminate

                (test "Connect with valid credentials" (lambda ()
                    (set! sendmail-connection (sendmail-connect-with-credentials "localhost" (server-port server) "account" "password"))
                    (assert (sendmail-connected? sendmail-connection))))

                (test "Connect with invalid credentials" (lambda ()
                    (set! sendmail-connection (sendmail-connect-with-credentials "localhost" (server-port server) "account" "wrong-password"))
                    (assert (not (sendmail-connected? sendmail-connection)))))
            ))

            (capability 'lazy-connection (list

                (define (some-send connection)
                    (sendmail-send-message connection "message content" "sender@sender.to" '("user@recipient.to")))

                (test "Connect with valid credentials" (lambda ()
                    (set! sendmail-connection (sendmail-connect-with-credentials "localhost" (server-port server) "account" "password"))
                    (assert (all? send-success? (some-send sendmail-connection)))))

                (test "Connect with invalid credentials" (lambda ()
                    (set! sendmail-connection (sendmail-connect-with-credentials "localhost" (server-port server) "account" "wrong-password"))
                    (assert (all? send-error? (some-send sendmail-connection)))))
            ))            

        ))

        ; This covers full scenarios for sending a message that may be covered by convenience functions or
        ; require bridge implementors to use the commands directly
        (capability 'send-message (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))

            (test "Send a message" (lambda () 
                (let
                    ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                    (assert (all? send-success? responses)))))

            (test "Send a message to multiple recipients" (lambda () 
                (let
                    ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user1@recipient.to" "user2@recipient.to"))))
                    (assert (all? send-success? responses)))))

            (test "Send a message with empty recipient" (lambda () 
                (let
                    ((responses (sendmail-send-message smtp-connection "message content" "<>" '("user@recipient.to"))))
                    (assert (all? send-success? responses) "Client should be able to send message with empty recipient")
                    (assert
                        (any?
                            (lambda (request) 
                                (string-prefix? "FROM:<>" (first (request-arguments request))))
                            (server-requests-with-command server "MAIL"))
                        (string-append "Expected client to send empty sender: " (server-requests-with-command server "MAIL"))))))

            (test "Send a message to cc recipients" (lambda () 
                (let
                    ((responses (sendmail-send-message-full smtp-connection "message content" "sender@sender.to" '() '("user1@recipient.to") '() (make-hash-table) (make-hash-table) '() '())))
                    (assert (all? send-success? responses))
                    (assert (server-message-contains? "user1@recipient.to"))
                    (assert
                        (any?
                            (lambda (request) 
                                (string-prefix-ci? "TO:<user1@recipient.to>" (first (request-arguments request))))
                            (server-requests-with-command server "RCPT"))
                        (string-append "Expected client to send RCPT command for cc recipients: " (server-requests-with-command server "RCPT"))))))

            (test "Send a message to bcc recipients" (lambda () 
                (let
                    ((responses (sendmail-send-message-full smtp-connection "message content" "sender@sender.to" '() '() '("user1@recipient.to") (make-hash-table) (make-hash-table) '() '())))
                    (assert (all? send-success? responses))
                    (assert (not (server-message-contains? "user1@recipient.to")))
                    (assert
                        (any?
                            (lambda (request) 
                                (string-prefix-ci? "TO:<user1@recipient.to>" (first (request-arguments request))))
                            (server-requests-with-command server "RCPT"))
                        (string-append "Expected client to send RCPT command for bcc recipients: " (server-requests-with-command server "RCPT"))))))

            ; TODO
            ;(test "Send message with a valid and an invalid recipient" (lambda () 
            ;    (let
            ;       ((response (sendmail-send-message smtp-connection "message content" ""))))))

            (data-test "Failures during send message" 
                '(("400 BUSY")
                ("502 SYNTAX ERROR")
                ("530 AUTH ERROR")
                ("520 FATAL ERROR"))
                (lambda (response-code)
                    (server-set-response-code! server response-code)
                    (let
                        ((responses 
                            (sendmail-send-message smtp-connection "failure content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses) (string-append "Expected client to fail when server responds with error:" response-code)))))

            (capability 'handle-421 (list
                ; As send-message handles multiple commands and responses, it also needs to deal with responses that
                ; indicate that the connection has been terminated.
                (test "Handle 421 during mail command" (lambda ()
                    (server-set-command-response-code! server "MAIL" "421 Service not available")
                    (let
                        ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses))
                        (assert (not (sendmail-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 during rcpt command" (lambda ()
                    (server-set-command-response-code! server "RCPT" "421 Service not available")
                    (let
                        ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses))
                        (assert (not (sendmail-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 at start of data command" (lambda ()
                    (server-set-command-response-code! server "DATA" "421 Service not available")
                    (let
                        ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses))
                        (assert (not (sendmail-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 during data command" (lambda ()
                    (server-set-command-response-code! server "DATA MIDDLE" "421 Service not available")
                    (let
                        ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses))
                        (assert (not (sendmail-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 at the end of data command" (lambda ()
                    (server-set-command-response-code! server "DATA END" "421 Service not available")
                    (let
                        ((responses (sendmail-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert (all? send-error? responses))
                        (assert (not (sendmail-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

            ))

        ))

        (capability 'headers (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))

            (test "set basic header" (lambda ()
                (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table '(("x-my-header" "some value"))))
                (assert (server-message-contains? "x-my-header: some value") (string-append "Expected x-my-header to be present, but instead got " (server-message-data server)))))

            (test "set header with unicode value" (lambda ()
                (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table '(("x-my-header" "¡some value"))))
                (assert 
                    (server-message-contains-ci? "x-my-header: =?utf-8?q?=C2=A1some?= value")
                    (string-append "Expected x-my-header to contain encoded ¡, but instead got " (server-message-data server)))
                (assert
                    (server-message-contains? "message content")
                    (string-append "Expected message content to be unaltered by unicode header value, but instead got" (server-message-data server)))))

            (test "set override standard header" (lambda ()
                (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table '(("To" "another-user@recipient.to"))))
                (assert (server-message-contains? "To: another-user@recipient.to") (string-append "Expected To header field to include another-user..., but instead got " (server-message-data server)))))

            (capability 'crlf-injection (list

                (capability 'detection (list
                    
                    (data-test "CRLF detection in basic header value" 
                        '(("1some\rvalue") ("2some\nvalue") ("3some\r\nvalue"))
                        (lambda (header-value)
                            (let 
                                ((responses (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table (list (list "x-my-header" header-value))))))
                                (assert (all? send-error? responses) (string-append "The header value: " header-value " should have resulted in error but did not:" responses)))))

                    (data-test "CRLF detection in unicode header value" 
                        '(("1¡some\rvalue") ("2¡some\nvalue") ("3¡some\r\nvalue"))
                        (lambda (header-value)
                            (let 
                                ((responses (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table (list (list "x-my-header" header-value))))))
                                (assert (all? send-error? responses) (string-append "The header value: " header-value " should have resulted in error but did not:" responses)))))

                ))

                (capability 'mitigation (list

                    (data-test "CRLF mitigation in basic header value" 
                        '(("1some\rvalue") ("2some\nvalue") ("3some\r\nvalue"))
                        (lambda (header-value)
                            (let 
                                ((responses (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table (list (list "x-my-header" header-value))))))
                                (assert (all? send-success? responses) (string-append "Message was not sent successfully, instead got: " responses))
                                (assert (not (server-message-contains? header-value)) (string-append "The header value: " header-value " should have been stripped of CRLF but did not:" (server-message-data server))))))

                    (data-test "CRLF mitigation in unicode header value" 
                        '(("1¡some \rvalue" "\rvalue") ("2¡some \nvalue" "\nvalue") ("3¡some \r\nvalue" "\r\nvalue"))
                        (lambda (header-value fragment)
                            (let 
                                ((responses (sendmail-send-message-with-headers smtp-connection "message content" "sender@sender.to" '("user@recipient.to") (alist->hash-table (list (list "x-my-header" header-value))))))
                                (assert (all? send-success? responses) (string-append "Message was not sent successfully, instead got: " responses))
                                (assert (not (server-message-contains? fragment)) (string-append "The header value: " header-value " should have been stripped of CRLF but did not: " (server-message-data server))))))

                ))
            ))

        ))

        (capability 'attachments (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))

            ; attachments-properties is a list of alists with the following keys: 
            ; "data", "file-name", "content-type", or "content-disposition"
            (define sendmail-send-with-attachments (lambda attachments-properties
                (let 
                    ((properties-hashs (map alist->hash-table attachments-properties)))
                    (for-each 
                        (lambda (property-hash)
                            (if (not (hash-table-exists? property-hash "content-disposition"))
                                (hash-table-set! property-hash "content-disposition" "attachment")))
                        properties-hashs)
                    (sendmail-send-message-full 
                        smtp-connection
                        "message content" "sender@sender.to" '("recipient@recipient.to")
                        '() '()
                        (make-hash-table)
                        properties-hashs
                        '() '()))))
                
            (test "basic single text attachment" (lambda ()
                (sendmail-send-with-attachments 
                    '(("data" "info.txt")
                      ("file-name" "info.txt")
                      ("content-type" "text/plain")))
                (assert 
                    (or
                        (server-message-contains? "content of info file")
                        (server-message-contains? "Y29udGVudCBvZiBpbmZvIGZpbGU=")) 
                    (string-append "Expected server to receive message with text attachment, but received: " (server-message-data server)))
                (assert 
                    (server-message-contains-ci? "content-disposition: attachment")
                    (string-append "Expected server to receive message with content-disposition: attachment, but received: " (server-message-data server)))))

            (test "basic multiple text attachments" (lambda ()
                (sendmail-send-with-attachments 
                    '(("data" "info.txt")
                      ("file-name" "info.txt")
                      ("content-type" "text/plain"))
                    '(("data" "info.txt") 
                      ("file-name" "second-info.txt")
                      ("content-type" "text/plain")))
                (assert 
                    (and (server-message-contains-ci? "info.txt") (server-message-contains-ci? "second-info.txt"))
                    (string-append "Expected server to receive message with two attachments, but received: " (server-message-data server)))))

            (test "basic image attachment" (lambda ()
                (sendmail-send-with-attachments 
                    '(("data" "test.png")
                      ("file-name" "test.png")
                      ("content-type" "image/png")))
                (assert 
                    ; only part of base64 encoded image
                    (server-message-contains? "iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAAAXNSR0IArs4c6QAAAARnQU1BAACx")  
                    (string-append "Expected server to receive message with image attachment, but received: " (server-message-data server)))
                (assert 
                    (server-message-contains-ci? "content-disposition: attachment")
                    (string-append "Expected server to receive message with content-disposition: attachment, but received: " (server-message-data server)))))

            (test "multiple attachments with same name" (lambda ()
                (sendmail-send-with-attachments
                    '(("data" "info.txt") 
                      ("file-name" "info.txt")
                      ("content-type" "text/plain"))
                      
                    '(("data" "info.txt")
                      ("file-name" "info.txt")
                      ("content-type" "text/plain")))
                (assert 
                    (= 2 (length (string-contains-every? (server-message-data server) "info.txt"))) 
                    (string-append "Expected server to receive message with two text attachments with the same name, but received: " (server-message-data server)))))

            ; Filename property is optional: https://datatracker.ietf.org/doc/html/rfc2183#section-1
            (test "attachment without a name" (lambda ()
                (sendmail-send-with-attachments
                    '(("data" "info.txt")
                      ("content-type" "text/plain")))
                (assert 
                    (server-message-contains-ci? "content-disposition: attachment")
                    (string-append "Expected server to receive a message with an attachment, but received: " (server-message-data server)))
                (assert
                    (not (server-message-contains-ci? "info.txt"))
                    (string-append "Expected server to receive a message with an attachment without a name, but received: " (server-message-data server)))))

            (test "image attachment with inline disposition" (lambda ()
                (sendmail-send-with-attachments
                    '(("data" "test.png")
                      ("file-name" "test.png")
                      ("content-type" "image/png")
                      ("content-disposition" "inline")))
                (assert
                    (server-message-contains-ci? "content-disposition: inline")
                    (string-append "Expected server to receive a message with an inline attachment, but received: " (server-message-data server)))))

            (test "text attachment with inline disposition" (lambda ()
                (sendmail-send-with-attachments
                    '(("data" "info.txt")
                      ("file-name" "info.txt")
                      ("content-type" "text/plain")
                      ("content-disposition" "inline")))
                (assert 
                    (server-message-contains-ci? "content-disposition: inline")
                    (string-append "Expected server to receive a message with an inline attachment, but received: " (server-message-data server)))))

            ; - inline attachment with cid? https://www.rfc-editor.org/rfc/rfc2392
            ; => non-trivial as we either need to do it completely manually or use a template engine. A template engine has 
            ; custom syntax, so we can not create a general scenario for it

            (capability 'automatic-mime-detection (list

            ))

            (capability 'unicode-file-name (list
                
            ))

        ))

        (capability 'general-crlf-injection (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))

            (define (assert-crlf-injection-error test-function failure-description)
                (let
                    ((response (test-function)))
                    (assert (send-error? response) failure-description)))

            (define (assert-crlf-injection-mitigation test-function injection command failure-description)
                (let
                    ((response (test-function)))
                    (assert (send-success? response))
                    (assert 
                        (all? 
                            (lambda (c) (not (string-index c injection))) 
                            (server-requests-with-command server command))
                        failure-description)))

            (capability 'detection (list

                (data-test "CRLF detection in send-message sender"
                    '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                    (lambda (sender-string)
                        (let
                            ((responses (sendmail-send-message smtp-connection "message content" sender-string '("user@recipient.to"))))
                            (display responses)
                            (assert (all? send-error? responses) (string-append "Expected client to fail when CR or LF is in sender of send-message: " sender-string)))))
                        
                (data-test "CRLF detection in send-message recipient"
                    '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                    (lambda (recipient-string)
                        (let
                            ((responses (sendmail-send-message smtp-connection "message content" "sender@email.com" (list recipient-string))))
                            (assert (all? send-error? responses) (string-append "Expected client to fail when CR or LF is in recipient of send-message: " recipient-string)))))
        
            ))

            (capability 'mitigation (list

                (data-test "CRLF mitigation in send-message sender"
                    '(("foo\r\nbar@email.com" "\r\n") ("foo\nbar@email.com" "\n") ("foo\rbar@email.com" "\r")) 
                    (lambda (sender-string injection)
                        (let
                            ((responses (sendmail-send-message smtp-connection "message content" sender-string '("user@recipient.to"))))
                            (assert (all? send-success? responses))
                            (assert 
                                (all? 
                                    (lambda (c) (not (string-index c injection))) 
                                    (server-requests-with-command server "MAIL"))
                                (string-append "Expected client to remove CR or LF or both from sender of send-message: " sender-string)))))
                        
                (data-test "CRLF mitigation in send-message recipient"
                    '(("foo\r\nbar@email.com" "\r\n") ("foo\nbar@email.com" "\n") ("foo\rbar@email.com" "\r")) 
                    (lambda (recipient-string injection)
                        (let
                            ((responses (sendmail-send-message smtp-connection "message content" "sender@email.com" (list recipient-string))))
                            (assert (all? send-success? responses))
                            (assert 
                                (all? 
                                    (lambda (c) (not (string-index c injection))) 
                                    (server-requests-with-command server "RCPT"))
                                (string-append "Expected client to remove CR or LF or both from recipients of send-message: " recipient-string)))))
            ))
                    
        ))

        (capability 'unicode-messages (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))

            (capability '8bitmime (list

                (define (activate-8bitmime server) 
                    (server-set-extensions! server '("8BITMIME")))
        
                ; The library can handle unicode messages by using the 8BITMIME extension but users have to set the option explicitly.
                (capability 'mandatory-options (list

                    ; 6152 - Section 3, end of section 
                    (test "non-ascii content in send-message with 8BITMIME option and without 8BITMIME server support" (lambda ()
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '("BODY=8BITMIME") '())))
                            (assert (all? send-error? send-message-responses) "Client should not support sending 8BITMIME body when server does not support it"))))

                    ; Use fallback encoding when 8BITMIME options was not set (independent of server support) and should not just go ahead with unicode anyway
                    (test "non-ascii content in send-message without 8BITMIME option" (lambda ()
                        (activate-8bitmime server)
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert (all? send-success? send-message-responses))    
                            (assert 
                                (not (server-message-contains? "¡a test message containing unicode!")))
                                (string-append 
                                    "Expected server to receive message with unicode content encoded, but received: " (server-message-data server)))))

                    (test "non-ascii content in send-message with 8BITMIME option and server support" (lambda ()
                        (activate-8bitmime server)
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '("BODY=8BITMIME") '())))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<sender@sender.com> BODY=8BITMIME")
                            (assert 
                                (server-message-contains? "¡a test message containing unicode!")
                                (string-append 
                                    "Expected server to receive message with unicode content directly, but received: " (server-message-data server))))))
                
                ))

                ; The library can handle unicode messages by using the 8BITMIME extension and detects it automatically.
                (capability 'automatic-detection (list

                    (test "non-ascii content in send-message without 8BITMIME support" (lambda ()
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert-any-request server "MAIL FROM:<sender@sender.com>")
                            (assert 
                                (not (server-message-contains? "¡a test message containing unicode!"))
                                (string-append 
                                    "Expected server to receive message with unicode content directly, but received: " (server-message-data server))))))

                    (test "non-ascii content in send-message with 8BITMIME support" (lambda ()
                        (activate-8bitmime server)
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<sender@sender.com> BODY=8BITMIME")
                            (assert 
                                (server-message-contains? "¡a test message containing unicode!")
                                (string-append 
                                    "Expected server to receive message with unicode content directly, but received: " (server-message-data server))))))
                
                ))
            ))
        ))

        (capability 'internationalized-email-addresses (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (sendmail-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda () 
                (sendmail-disconnect smtp-connection)
                (set! smtp-connection '())))


            (capability 'smtputf8 (list

                ; RFC 6531 3.1 - Item 8 
                ; 8BITMIME is required, as we would normally expect international mailboxes to also
                ; appear in the message headers, thus the DATA content
                (define (activate-smtputf8 server) 
                    (server-set-extensions! server '("SMTPUTF8" "8BITMIME")))

                (capability 'explicit-options (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert (all? send-error? send-message-responses)))))

                    (test "international recipient mailbox in send-message without SMTPUTF8 support and no option" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (all? send-error? send-message-responses)))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8 BODY=8BITMIME"))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support but no option" (lambda ()
                        (activate-smtputf8 server)
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (all? send-error? send-message-responses)))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert (all? send-error? send-message-responses)))))

                    (test "international sender mailbox in send-message without SMTPUTF8 support and no option" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (all? send-error? send-message-responses)))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8 BODY=8BITMIME"))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support but no option" (lambda ()
                        (activate-smtputf8 server)
                        
                        (let
                            ((send-message-responses (sendmail-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (all? send-error? send-message-responses)))))
                ))

                (capability 'automatic-detection (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert (all? send-error? send-message-responses)))))  

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                    
                        (let
                            ((send-message-responses (sendmail-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8 BODY=8BITMIME"))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda ()
                        
                        (let
                            ((send-message-responses (sendmail-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert (all? send-error? send-message-responses)))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        
                        (let
                            ((send-message-responses (sendmail-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert (all? send-success? send-message-responses))
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8 BODY=8BITMIME"))))
                ))
            ))
        ))

    )
)