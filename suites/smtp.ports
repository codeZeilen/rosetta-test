(suite 
	"SMTP" "0.1"
    (sources 
		'("CPython SMTP tests" "Python Foundation" "https://github.com/python/cpython/blob/9ba2a4638d7b620c939face7642b2f53a9fadc4b/Lib/test/test_smtplib.py")
        '("Ruby net-smtp tests" "MRI maintainers" "https://github.com/ruby/net-smtp/blob/master/test/net/smtp/test_smtp.rb")
        '("SMTP RFC 2821" "IETF" "https://tools.ietf.org/html/rfc2821")
        '("SMTP RFC 5321" "IETF" "https://tools.ietf.org/html/rfc5321")
        '("SMTP RFC 4954" "IETF" "https://tools.ietf.org/html/rfc4954"))
    
    (list 
        ; Socket
        (placeholder '(create-socket) "Create a local network socket for the server to communicate through (it should already listen for new connections)")
        (placeholder '(socket-receive socket) "Read trimmed data from socket")
        (placeholder '(socket-write socket data) "Write data to socket")
        (placeholder '(socket-port socket) "Return the port of the socket")
        (placeholder '(socket-accept socket) "Accept a new connection on the socket")
        (placeholder '(socket-close socket) "Close the socket")
        (placeholder '(secure-server-socket-wrap socket ca-file cert-file key-file close-underlying-socket) "Should wrap an existing connected server socket with a secure socket (TLS/SSL) with the given configuration. Then the procedure should wait for the handshake (accept) to complete.")

        ; SMTP connection
        (placeholder '(smtp-connect host port) "Should connect and return some representation of the connection.")
        (placeholder '(smtp-connect-with-auto-starttls host port starttls-mode) "Should connect and set the automatic starttls mode (which can be 'automatic (send starttls if available, otherwise do not), 'required (connect and send starttls, fail if server does not support it), 'never (do not automatically send starttls)). In case the connection results in an error (e.g. starttls mode is 'required but server does not support starttls), the error should be returned.")
        (placeholder '(smtp-secure-connect host port ca-file) "Should connect to an SMTP server via a secure connection (SSL/TLS) and return some representation of the connection.")
        (placeholder '(smtp-secure-connect-with-timeout host port ca-file timeout) "Same as smtp-secure-connect but the connection should be aborted if the handshake does not complete within the timeout.")
        (placeholder '(smtp-disconnect connection) "Should close the connection")
        (placeholder '(smtp-connected? connection) "Should return true if the connection is still open")

        ; SMTP commands
        (placeholder '(smtp-ehlo connection content) "Send an EHLO command to the server")
        (placeholder '(smtp-mail-with-options connection from options) "Send a MAIL command to the server, supplying optional options (provided as a list of strings, that can be joined using compile-options-string if necessary).")
        (define (smtp-mail connection from) 
            (smtp-mail-with-options connection from '()))
        (placeholder '(smtp-rcpt connection to-list options-list) "Send a RCPT command to the server. The to parameter should be a list of recipients. The function should return a list of responses from the server. Whether the RCPT commands are send by multiple invocations or a single one can be decided by the placeholder. The options list contains lists of options, one list of options per receipient. The list of options contains tuples with the option name as the first element, and the option value as the second. Clients may use the functions compile-options-strings, compile-options-string, and compile-option-string to compile the options list into key-value-strings that can be sent to the server.")
        (placeholder '(smtp-data connection content) "Send a DATA command to the server for transmitting the content. The content should be a string and not contain the SMTP data terminating sequence.")
        (placeholder '(smtp-rset connection) "Send a RST command to the server")
        (placeholder '(smtp-vrfy connection content) "Send a VRFY command to the server with content being the string to verify")
        (placeholder '(smtp-help connection content) "Send a HELP command to the server with content being the string to get help for.")
        (placeholder '(smtp-expn connection content) "Send an EXPN command to the server with content being the list to expand. The response is an object that can be inspected with smtp-response-code and smtp-expn-response-users-list.")
        (placeholder '(smtp-starttls connection cert-file key-file) "Send a STARTTLS command to the server. The cert-file and key-file are optional.")
        (placeholder '(smtp-quit connection) "Send a QUIT command to the server")
        
        ; Send Message
        (placeholder '(smtp-send-message-with-options connection message-content from to-list message-options to-list-options) "Send a message to the server. The message-options and the to-list-options are optional. The to-list-options is a list of option tuple lists, one for each receiver. The function should return a list corresponding to the responses from the server for each recipient in the to-list. If there is only a single response, a list with a single response should be returned.")
        (define (smtp-send-message connection content from to-list)
            (smtp-send-message-with-options connection content from to-list  '() '()))
        
        ; Response accessors
        (placeholder '(smtp-response-code response) "Return the response code from the server")
        (placeholder '(smtp-response-message response) "Return the response message from the server")
        (placeholder '(smtp-error? response) "Returns true if the response represents an error of some kind. This does not include error responses from the server but rather errors in the client-server communication.")
        (placeholder '(smtp-extensions connection ehlo-response) "Return a list of extensions of the server, either from the connection or the ehlo response. The list can contain plain strings and tuples for extensions with parameters.") ; This is already an interesting case, as the extensions may be derived from only a response or may be a property of the connection object
        (placeholder '(smtp-extension-not-supported-error? response) "Did the command fail due to an unsupported extension?")
        (placeholder '(smtp-expn-response-users-list response) "Return the list of users from the EXPN response")

        ; Authentication
        (placeholder '(smtp-authenticate-initial-response connection method credentials initial-response) "Run authentication and return the result (in case of an exception return exception object or a stand-in for the exception). The method is a string and the credentials are a list of strings. The initial-response is a Boolean value and denotes whether an initial response should be send.")
        (define (smtp-authenticate connection method credentials)
            (smtp-authenticate-initial-response connection method credentials #f))
        (placeholder '(smtp-auth-successful?) "Was the authentication successful?")
        ; The following two are also interesting as this is an advanced feature that might be moved to a dedicated capability, but then it shares the same situation as the other unsuccessful auth tests
        (placeholder '(smtp-auth-credentials-error?) "Did the authentication fail due to wrong credentials?")
        (placeholder '(smtp-auth-not-supported-error?) "Did the authentication fail due to no compatible authentication method?")

        (include "suites/smtp-mock-server.scm")

        ; Compile one option to a string, either from a tuple (KEY VALUE|VALUES) to "KEY=VALUE,VALUE"
        ; or if already a string, simply return it.
        (define (compile-option-string option)
            (if (list? option)
                (string-append 
                    (first option)
                    "="
                    (if (list? (last option)) 
                        (string-join (last option) ",") 
                        (last option)))
                ; If not a list, just retrun
                option))

        ; Compile a list of option tuples to a list of strings
        (define (compile-options-strings options) 
            (map compile-option-string options))

        ; Compile a list of option strings to a single string that can be sent to the server
        (define (compile-options-string options) 
            (string-join (compile-options-strings options) " "))

        (define (assert-response-code response code) (assert-equal code (smtp-response-code response)))
        (define (assert-response-codes responses code) (
            for-each 
                (lambda (response) (assert-response-code response code))
                responses))

        (setup (lambda ()  
            (set! server '())))

        (tearDown (lambda () 
            (stop-mock-server)))

        ;
        ; Capabilities
        ;

        (capability 'connection (list

            (setup (lambda ()
                (set! server (start-mock-server))))

            (test "Connect to server" (lambda () 
                (assert (smtp-connected? (smtp-connect "localhost" (server-port server))))))

            (test "Connect with non-numeric port is an error" (lambda ()
                (let
                    ((result (smtp-connect "localhost" "not-a-port")))
                    (assert (smtp-error? result) (string-append "Expected " result " to be an SMTP error"))
                    (smtp-connect "localhost" (server-port server))))) ; Give the mock server a chance to terminate 
        ))

        (capability 'tls-connection (list

            (define original-secure-server-socket-wrap '())

            (define start-tls-mock-server (lambda () 
                (set! server (server-start (create-server #t)))))

            (tearDown (lambda ()
                (if (not (= original-secure-server-socket-wrap '()))
                    (begin
                        (set! secure-server-socket-wrap original-secure-server-socket-wrap)
                        (set! original-secure-server-socket-wrap '())))))

            (test "Connect to server with TLS" (lambda ()
                (start-tls-mock-server)
                (smtp-secure-connect "localhost" (server-port server) "./smtp-fixtures/cacert.pem")))

            (test "Timeout during connect to server with TLS" (lambda ()
                (set! original-secure-server-socket-wrap secure-server-socket-wrap)
                (set! secure-server-socket-wrap (lambda (socket x xx xxx xxxx) (begin 
                    (thread-sleep! 0.5)
                    (socket-close socket))))
                (start-tls-mock-server)
                (assert (smtp-error? (smtp-secure-connect-with-timeout "localhost" (server-port server) "./smtp-fixtures/cacert.pem" 0.1)))))
            
        ))

        (capability 'crlf-injection-detection (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)
                (smtp-ehlo smtp-connection "")))

            (tearDown (lambda ()
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '())))

            (define (assert-crlf-injection-error test-function failure-description)
                (let
                    ((response (test-function)))
                    (assert (smtp-error? response) failure-description)))

            (define (assert-crlf-injection-mitigation test-function injection command failure-description)
                (let
                    ((response (test-function)))
                    (assert-response-code response 250)
                    (assert 
                        (all? 
                            (lambda (c) (not (string-index c injection))) 
                            (server-requests-with-command server command))
                        failure-description)))
                

            (capability 'commands (list

                (capability 'detection (list

                    (capability 'ehlo (list
                        (data-test "CRLF detection in EHLO command"
                            '(("email.\r\nemail") ("email.\nemail") ("email\remail")) 
                            (lambda (hostname-string) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (smtp-ehlo smtp-connection hostname-string))
                                    (string-append "Expected client to fail when CR or LF is in EHLO hostname argument: " hostname-string)))))))

                    (capability 'vrfy (list
                        (data-test "CRLF detection in VRFY command"
                            '(("email@\r\nemail") ("email@\nemail") ("email@\remail")) 
                            (lambda (address-string) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (smtp-vrfy smtp-connection address-string))
                                    (string-append "Expected client to fail when CR or LF is in VRFY message argument: " address-string)))))))

                    (capability 'expn (list
                        (data-test "CRLF detection in EXPN command"
                            '(("email\r\nlist") ("email\nlist") ("email\rlist")) 
                            (lambda (address-string) (begin
                                (server-set-response-code! server "250") 
                                (assert-crlf-injection-error 
                                    (lambda () (smtp-expn smtp-connection address-string))
                                    (string-append "Expected client to fail when CR or LF is in EXPN command: " address-string)))))))

                    (capability 'mail (list
                        (data-test "CRLF detection in MAIL command"
                            '(("foo\r\nbar") ("foo\nbar") ("foo\rbar")) 
                            (lambda (sender-string) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (smtp-mail smtp-connection sender-string))
                                    (string-append "Expected client to fail when CR or LF is in MAIL command: " sender-string)))))
                                    
                                    
                        (data-test "CRLF detection in MAIL command - options"
                            '((("X-OPTION\r\nX-INJECTED-1" "X-OPTION2\r\nX-INJECTED-2")) (("X-OPTION\nX-INJECTED-1" "X-OPTION2\nX-INJECTED-2")) (("X-OPTION\rX-INJECTED-1" "X-OPTION2\rX-INJECTED-2"))) 
                            (lambda (options-list) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (smtp-mail-with-options smtp-connection "foo@bar.com" options-list))
                                    (string-append "Expected client to fail when CR or LF is in MAIL option argument: " options-list)))))))


                    (capability 'rcpt (list
                        (data-test "CRLF detection in RCPT command - recipient"
                            '(("foo\r\nbar") ("foo\nbar") ("foo\rbar")) 
                            (lambda (recipient-string) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (first (smtp-rcpt smtp-connection (list recipient-string) '())))
                                    (string-append "Expected client to fail when CR or LF is in RCPT command: " recipient-string)))))

                        (data-test "CRLF detection in RCPT command - options"
                            '((("X-OPTION\r\nX-INJECTED-1" "X-OPTION2\r\nX-INJECTED-2")) (("X-OPTION\nX-INJECTED-1" "X-OPTION2\nX-INJECTED-2")) (("X-OPTION\rX-INJECTED-1" "X-OPTION2\rX-INJECTED-2"))) 
                            (lambda (options-list) (begin 
                                (assert-crlf-injection-error 
                                    (lambda () (first (smtp-rcpt smtp-connection (list "foo@bar.com") (list options-list))))
                                    (string-append "Expected client to fail when CR or LF is in RCPT option argument: " options-list)))))))

                
                ))

                (capability 'mitigation (list

                    (capability 'ehlo (list
                        (data-test "CRLF mitigation in EHLO command"
                            '(("email.\r\nemail" "\r\n") ("email.\nemail" "\n") ("email\remail" "\r")) 
                            (lambda (hostname-string injection) (begin 
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-ehlo smtp-connection hostname-string))
                                    injection
                                    "EHLO"
                                    (string-append "Expected client to remove CR or LF or both from EHLO command: " hostname-string)))))))

                    (capability 'vrfy (list
                        (data-test "CRLF mitigation in VRFY command"
                            '(("email@\r\nemail" "\r\n") ("email@\nemail" "\n") ("email@\remail" "\r"))  
                            (lambda (address-string injection) (begin 
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-vrfy smtp-connection address-string))
                                    injection
                                    "VRFY"
                                    (string-append "Expected client to remove CR or LF or both from VRFY command: " address-string)))))))

                    (capability 'expn (list
                        (data-test "CRLF mitigation in EXPN command"
                            '(("email\r\nlist" "\r\n") ("email\nlist" "\n") ("email\rlist" "\r"))  
                            (lambda (address-string injection) (begin 
                                (server-set-response-code! server "250 foo@bar")
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-expn smtp-connection address-string))
                                    injection
                                    "EXPN"
                                    (string-append "Expected client to remove CR or LF or both from EXPN command: " address-string)))))))

                    (capability 'help (list
                        (data-test "CRLF mitigation in HELP command"
                            '(("some\r\ncommand" "\r\n") ("some\ncommand" "\n") ("some\rcommand" "\r")) 
                            (lambda (command-string injection) (begin 
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-help smtp-connection command-string))
                                    injection
                                    "HELP"
                                    (string-append "Expected client to remove CR or LF or both from HELP command: " command-string)))))))

                    (capability 'mail (list
                        (data-test "CRLF mitigation in MAIL command"
                            '(("foo\r\nbar" "\r\n") ("foo\nbar" "\n") ("foo\rbar" "\r")) 
                            (lambda (sender-string injection) (begin 
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-mail smtp-connection sender-string))
                                    injection
                                    "MAIL"
                                    (string-append "Expected client to remove CR or LF or both from MAIL command: " sender-string)))))

                        (data-test "CRLF mitigation in MAIL command - options"
                            '((("X-OPTION\r\nX-INJECTED-1" "X-OPTION2\r\nX-INJECTED-2") "\r\n") (("X-OPTION\nX-INJECTED-1" "X-OPTION2\nX-INJECTED-2") "\n") (("X-OPTION\rX-INJECTED-1" "X-OPTION2\rX-INJECTED-2") "\r")) 
                            (lambda (options-list injection) (begin
                                (assert-crlf-injection-mitigation
                                    (lambda () (smtp-rcpt smtp-connection "foo@bar.com" options-list))
                                    injection
                                    "MAIL"
                                    (string-append "Expected client to remove CR or LF or both from MAIL options argument: " options-list)))))))

                    (capability 'rcpt (list
                        (data-test "CRLF mitigation in RCPT command - recipient"
                            '(("foo\r\nbar" "\r\n") ("foo\nbar" "\n") ("foo\rbar" "\r")) 
                            (lambda (recipient-string injection) (begin
                                (assert-crlf-injection-mitigation
                                    (lambda () (first (smtp-rcpt smtp-connection (list recipient-string) '())))
                                    injection
                                    "RCPT"
                                    (string-append "Expected client to remove CR or LF or both from RCPT command: " recipient-string)))))

                        (data-test "CRLF mitigation in RCPT command - options"
                            '((("X-OPTION\r\nX-INJECTED-1" "X-OPTION2\r\nX-INJECTED-2") "\r\n") (("X-OPTION\nX-INJECTED-1" "X-OPTION2\nX-INJECTED-2") "\n") (("X-OPTION\rX-INJECTED-1" "X-OPTION2\rX-INJECTED-2") "\r")) 
                            (lambda (options-list injection) (begin
                                (assert-crlf-injection-mitigation
                                    (lambda () (first (smtp-rcpt smtp-connection (list "foo@bar.com") (list options-list))))
                                    injection
                                    "RCPT"
                                    (string-append "Expected client to remove CR or LF or both from RCPT options argument: " options-list)))))))
                
                ))
            
            ))

            (capability 'send-message (list

                (capability 'detection (list

                    (data-test "CRLF detection in send-message sender"
                        '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                        (lambda (sender-string) (begin 
                            (let
                                ((responses (smtp-send-message smtp-connection "message content" sender-string '("user@recipient.to"))))
                                (display responses)
                                (assert (all? smtp-error? responses) (string-append "Expected client to fail when CR or LF is in sender of send-message: " sender-string))))))
                            
                    (data-test "CRLF detection in send-message recipient"
                        '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                        (lambda (recipient-string) (begin 
                            (let
                                ((responses (smtp-send-message smtp-connection "message content" "sender@email.com" (list recipient-string))))
                                (assert (all? smtp-error? responses) (string-append "Expected client to fail when CR or LF is in recipient of send-message: " recipient-string))))))
            
                ))

                (capability 'mitigation (list

                    (data-test "CRLF mitigation in send-message sender"
                        '(("foo\r\nbar@email.com" "\r\n") ("foo\nbar@email.com" "\n") ("foo\rbar@email.com" "\r")) 
                        (lambda (sender-string injection) (begin 
                            (let
                                ((responses (smtp-send-message smtp-connection "message content" sender-string '("user@recipient.to"))))
                                (assert-response-codes responses 250)
                                (assert 
                                    (all? 
                                        (lambda (c) (not (string-index c injection))) 
                                        (server-requests-with-command server "MAIL"))
                                    (string-append "Expected client to remove CR or LF or both from sender of send-message: " sender-string))))))
                            
                    (data-test "CRLF mitigation in send-message recipient"
                        '(("foo\r\nbar@email.com" "\r\n") ("foo\nbar@email.com" "\n") ("foo\rbar@email.com" "\r")) 
                        (lambda (recipient-string injection) (begin 
                            (let
                                ((responses (smtp-send-message smtp-connection "message content" "sender@email.com" (list recipient-string))))
                                (assert-response-codes responses 250)
                                (assert 
                                    (all? 
                                        (lambda (c) (not (string-index c injection))) 
                                        (server-requests-with-command server "RCPT"))
                                    (string-append "Expected client to remove CR or LF or both from recipients of send-message: " recipient-string))))))
                ))

            ))
                    
        ))

        ; This covers full scenarios for sending a message that may be covered by convenience functions or
        ; require bridge implementors to use the commands directly
        (capability 'send-message (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)
                (smtp-ehlo smtp-connection "")))

            (tearDown (lambda ()
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '())))

            (test "Send a message" (lambda () 
                (let
                    ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                    (assert-response-codes response 250))))

            (test "Send a message to multiple recipients" (lambda () 
                (let
                    ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user1@recipient.to" "user2@recipient.to"))))
                    (assert-response-codes response 250))))

            (test "Send a message with empty recipient" (lambda () 
                (let
                    ((response (smtp-send-message smtp-connection "message content" "<>" '("user@recipient.to"))))
                    (assert-response-codes response 250)
                    (assert
                        (any?
                            (lambda (request) 
                                (string-prefix? "FROM:<>" (first (request-arguments request))))
                            (server-requests-with-command server "MAIL"))
                        (string-append "Expected client to send empty sender: " (server-requests-with-command server "MAIL"))))))

            ; TODO
            ;(test "Send message with a valid and an invalid recipient" (lambda () 
            ;    (let
            ;       ((response (smtp-send-message smtp-connection "message content" ""))))))

            (data-test "Failures during send message" 
                '(("400 BUSY" 400)
                ("502 SYNTAX ERROR" 502)
                ("530 AUTH ERROR" 530)
                ("520 FATAL ERROR" 520))
                (lambda (response response-code) (begin 
                    (server-set-response-code! server response)
                    (let
                        ((response 
                            (smtp-send-message smtp-connection "failure content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response response-code)))))

            (capability 'handle-421 (list
                ; As send-message handles multiple commands and responses, it also needs to deal with responses that
                ; indicate that the connection has been terminated.
                (test "Handle 421 during mail command" (lambda ()
                    (server-set-command-response-code! server "MAIL" "421 Service not available")
                    (let
                        ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response 421)
                        (assert (not (smtp-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 during rcpt command" (lambda ()
                    (server-set-command-response-code! server "RCPT" "421 Service not available")
                    (let
                        ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response 421)
                        (assert (not (smtp-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 at start of data command" (lambda ()
                    (server-set-command-response-code! server "DATA" "421 Service not available")
                    (let
                        ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response 421)
                        (assert (not (smtp-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 during data command" (lambda ()
                    (server-set-command-response-code! server "DATA MIDDLE" "421 Service not available")
                    (let
                        ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response 421)
                        (assert (not (smtp-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

                (test "Handle 421 at the end of data command" (lambda ()
                    (server-set-command-response-code! server "DATA END" "421 Service not available")
                    (let
                        ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response 421)
                        (assert (not (smtp-connected? smtp-connection)) "421 should have lead to client terminating connection."))))

            ))

        ))

        (capability '8bitmime (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda ()
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '())))

            (define (activate-8bitmime server) 
                (server-set-extensions! server '("8BITMIME")))

            (capability 'manual-commands (list

                (test "full 8BITMIME scenario" (lambda () 
                    (activate-8bitmime server)
                    (smtp-ehlo smtp-connection "")
                    (let ((mail-response (smtp-mail-with-options smtp-connection "sender@sender.com" '("BODY=8BITMIME"))))
                        (assert-any-request server "MAIL FROM:<sender@sender.com> BODY=8BITMIME")
                        (assert-response-code mail-response 250)
                        (smtp-rcpt smtp-connection '("recipient@recipient.com") '())
                        (let 
                            ((data-response (smtp-data smtp-connection "¡a test message containing unicode!")))
                            (assert-response-code mail-response 250)))))

            ))

            (capability 'send-message (list
    
                (capability 'explicit-options (list

                    ; 6152 - Section 3, end of section 
                    (test "non-ascii content in send-message without 8BITMIME support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '("BODY=8BITMIME") '())))
                            (assert (all? smtp-error? send-message-responses) "Client should not support sending 8BITMIME body when server does not support it"))))

                    (test "non-ascii content in send-message without 8BITMIME support and no option" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "non-ascii content in send-message with 8BITMIME support and option" (lambda ()
                        (activate-8bitmime server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '("BODY=8BITMIME") '())))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> BODY=8BITMIME"))))

                    (test "non-ascii content in send-message with 8BITMIME support and no option" (lambda ()
                        (activate-8bitmime server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))
                
                ))

                (capability 'automatic-8bitmime-detection (list

                    (test "non-ascii content in send-message without 8BITMIME support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "non-ascii content in send-message with 8BITMIME support" (lambda ()
                        (activate-8bitmime server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "¡a test message containing unicode!" "sender@sender.com" '("user@recipient.com") '() '())))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> BODY=8BITMIME"))))
                
                ))

            ))

        ))

        (capability 'smtputf8 (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () 
                (set! server (start-mock-server))
                (connect-smtp-server)))

            (tearDown (lambda () 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '())))

            ; RFC 6531 3.1 - Item 8 
            ; 8BITMIME is required, as we would normally expect international mailboxes to also
            ; appear in the message headers, thus in the DATA content. However they might also
            ; be encoded as BASE64 or QUOTED-PRINTABLE, which would not require 8BITMIME.
            (define (activate-smtputf8 server) 
                (server-set-extensions! server '("SMTPUTF8" "8BITMIME")))

            (capability 'mail (list

                (capability 'explicit-options (list
                    (test "International mailbox in mail without SMTPUTF8 support" (lambda ()
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("SMTPUTF8"))))
                            (assert (smtp-error? mail-response)))))

                    (test "International mailbox in mail without SMTPUTF8 support and no option" (lambda ()
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '())))
                            (assert (smtp-error? mail-response)))))

                    (test "international mailbox in mail with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("SMTPUTF8"))))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8"))))

                    (test "international mailbox in mail with SMTPUTF8 support but no option" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '())))
                            (assert (smtp-error? mail-response)))))
                ))

                (capability 'automatic-smtputf8-detection (list
                    (test "International mailbox in mail without SMTPUTF8 support" (lambda ()
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail smtp-connection "χρήστης@παράδειγμα.ελ")))
                            (assert (smtp-error? mail-response)))))

                    (test "international mailbox in mail with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail smtp-connection "χρήστης@παράδειγμα.ελ")))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8"))))    

                    (test "international mailbox in mail with SMTPUTF8 support and an unrelated option" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("RET=FULL"))))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> RET=FULL SMTPUTF8"))))
                ))
            ))

            (capability 'rcpt (list
                ; No test with server without SMTPUTF8 support, as the smtp-mail command would
                ; already fail to initiate a mail transaction.

                (test "international mailbox in rcpt with SMTPUTF8 support" (lambda ()
                    (activate-smtputf8 server)
                    (smtp-ehlo smtp-connection "")
                    (smtp-mail-with-options smtp-connection "sender@sender.com" '("SMTPUTF8"))
                    (let
                        ((rcpt-response (smtp-rcpt smtp-connection '("χρήστης@παράδειγμα.ελ") '())))
                        (assert-response-codes rcpt-response 250)
                        (assert-last-request server "RCPT TO:<χρήστης@παράδειγμα.ελ>"))))

                (test "international mailbox in rcpt with SMTPUTF8 support but no option" (lambda ()
                    (activate-smtputf8 server)
                    (smtp-ehlo smtp-connection "")
                    (smtp-mail-with-options smtp-connection "sender@sender.com" '())
                    (let
                        ((rcpt-response (first (smtp-rcpt smtp-connection '("χρήστης@παράδειγμα.ελ") '()))))
                        (assert (smtp-error? rcpt-response)))))
            ))

            (capability 'send-message (list
                ; The following tests do not include the BODY=8BITMIME options, as send-message 
                ; sends the provided message body as-is. In particular, it does not generate 
                ; message headers. Thereby the international characters do not reach the mail body
                ; and no 8BITMIME option is required.

                (capability 'explicit-options (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "international recipient mailbox in send-message without SMTPUTF8 support and no option" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8"))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support but no option" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "international sender mailbox in send-message without SMTPUTF8 support and no option" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8"))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support but no option" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (all? smtp-error? send-message-responses)))))
                ))

                (capability 'automatic-smtputf8-detection (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert (all? smtp-error? send-message-responses)))))  

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8"))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda ()
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert (all? smtp-error? send-message-responses)))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda ()
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-responses (smtp-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert-response-codes send-message-responses 250)
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8"))))
                ))

            ))

        ))

        (capability 'commands (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda ()
                (set! server (start-mock-server))))

            (tearDown (lambda () 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '())))

            (capability 'ehlo (list
                (setup (lambda () 
                    (connect-smtp-server)))

                (test "basic ehlo" (lambda () 
                    (smtp-ehlo smtp-connection "")))
                    
                (test "ehlo with identifier" (lambda () 
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "553.231.231.234")))
                        (assert-equal
                            250
                            (smtp-response-code ehlo-response))
                        (assert-equal
                            "553.231.231.234"
                            (smtp-response-message ehlo-response)))))

                (test "server answers a single extension" (lambda ()
                    (server-set-extensions! server (list "8BITMIME"))
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250)
                        (assert-extensions smtp-connection ehlo-response (list "8BITMIME")))))

                (test "server answers multiple extensions" (lambda ()
                    (server-set-extensions! server (list "8BITMIME" "VERB"))
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250)
                        (assert-extensions smtp-connection ehlo-response (list "8BITMIME" "VERB")))))

                (test "server answers extension with parameter" (lambda ()
                    (server-set-extensions! server (list "SIZE 2000"))
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250)
                        (assert-extensions smtp-connection ehlo-response (list '("SIZE" "2000"))))))

                (test "server answers ehlo with error code" (lambda ()
                    (server-set-response-code! server "550 not message")
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 550))))

                (test "two subsequent ehlos should be possible" (lambda ()
                    (smtp-ehlo smtp-connection "")
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250))))

                ))

            (capability 'rset (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic rset" (lambda ()
                    (server-set-response-code! server "250")
                    (let
                        ((rset-response (smtp-rset smtp-connection)))
                        (assert-response-code rset-response 250))))

                ))

            (capability 'expn (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic expn" (lambda ()
                    (server-set-response-code! server "250-Jon Postel <Postel@isi.edu>\r\n250-Fred Fonebone <Fonebone@physics.foo-u.edu>\r\n250 Sam Q. Smith <SQSmith@specific.generic.com>")
                    (let
                        ((expn-response (smtp-expn smtp-connection "Example-People")))
                        (assert-response-code expn-response 250)
                        (assert-equal
                            (smtp-expn-response-users-list expn-response)
                            (list "Jon Postel <Postel@isi.edu>" "Fred Fonebone <Fonebone@physics.foo-u.edu>" "Sam Q. Smith <SQSmith@specific.generic.com>")))))

                (test "error expn" (lambda ()
                    (server-set-response-code! server "550 Access Denied to You")
                    (let
                        ((expn-response (smtp-expn smtp-connection "Executive-Washroom-List")))
                        (assert-response-code expn-response 550))))
                ))


            (capability 'help (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic help" (lambda ()
                    (server-set-response-code! server "250 Supported commands: EHLO HELO MAIL")
                    (let
                        ((help-response (smtp-help smtp-connection "")))
                        (assert-response-code help-response 250)
                        (assert-equal (smtp-response-message help-response) "Supported commands: EHLO HELO MAIL"))))

                ))

            (capability 'vrfy (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                ; RFC 2821 - Section 3.5: https://datatracker.ietf.org/doc/html/rfc2821#section-3.5
                (data-test "verify of a valid email address" 
                    '(("250 The User <user@example.com>" "The User <user@example.com>")
                      ("250 <user@example.com>" "<user@example.com>")
                      ("250 user@example.com" "user@example.com"))
                    (lambda (response expected-message) (begin 
                        (server-set-response-code! server response)
                        (let
                            ((vrfy-response (smtp-vrfy smtp-connection "user@example.com")))
                            (assert-response-code vrfy-response 250)
                            (assert-equal expected-message (smtp-response-message vrfy-response))))))

                (test "verify of an email address with apparent validity" (lambda () 
                    (server-set-response-code! server "252 Cannot verify the user, but it will try to deliver the message anyway")
                    (let
                        ((vrfy-response (smtp-vrfy smtp-connection "user@otherserver.org")))
                        (assert-response-code vrfy-response 252)
                        (assert-equal "Cannot verify the user, but it will try to deliver the message anyway" (smtp-response-message vrfy-response)))))

                (test "verify of an unknown user" (lambda () 
                    (server-set-response-code! server "550 No such user")
                    (let
                        ((vrfy-response (smtp-vrfy smtp-connection "nouser")))
                        (assert-response-code vrfy-response 550)
                        (assert-equal "No such user" (smtp-response-message vrfy-response)))))

                ; TODO
                ;(test "verify resulting in forwarding response" (lambda () 
                ;    ))
                ;(test "verify resulting in mailbox disabled response" (lambda () 
                ;    ))

                ; RFC 2821 - Section 3.5: https://datatracker.ietf.org/doc/html/rfc2821#section-3.5
                (data-test "verify resulting in ambiguous user response" 
                    '(("553 User ambiguous" "User ambiguous")
                      ("553-Ambiguous;  Possibilities are\r\n553-Joe Smith <jsmith@foo.com>\r\n553 Melvin Smith <dweep@foo.com>" 
                        "Ambiguous;  Possibilities are\nJoe Smith <jsmith@foo.com>\nMelvin Smith <dweep@foo.com>")
                      ("553-Ambiguous;  Possibilities\r\n553-<jsmith@foo.com>\r\n553 <dweep@foo.com>" 
                        "Ambiguous;  Possibilities\n<jsmith@foo.com>\n<dweep@foo.com>"))
                    (lambda (response expected-message) (begin 
                        (server-set-response-code! server response)
                        (let
                            ((vrfy-response (smtp-vrfy smtp-connection "smith")))
                            (assert-response-code vrfy-response 553)
                            (assert-equal expected-message (smtp-response-message vrfy-response))))))
            
                ))

            (capability 'mail (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic mail" (lambda () 
                    (let
                        ((mail-response (smtp-mail smtp-connection "foo@example.com")))
                        (assert-response-code mail-response 250))))

                ; RFC 2476 - 3.2
                (test "mail with empty email address" (lambda () 
                    (let
                        ((mail-response (smtp-mail smtp-connection "")))
                        (assert-response-code mail-response 250)
                        (assert-last-request server "MAIL FROM:<>"))))

                (test "mail with invalid email address" (lambda () 
                    (let
                        ((mail-response (smtp-mail smtp-connection "invalid")))
                        (assert-response-code mail-response 500))))

                (test "mail with an option" (lambda () 
                    (let
                        ((mail-response (smtp-mail-with-options smtp-connection "sender@sender.com" '("SIZE=1234"))))
                        (assert-response-code mail-response 250)
                        (assert-last-request server "MAIL FROM:<sender@sender.com> SIZE=1234"))))
                

                ))

            (capability 'data (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic data" (lambda () 
                    (let
                        ((data-response (smtp-data smtp-connection "message content")))
                        (assert-response-code data-response 250))))

                ; Client should not be confused by an accidental message content termination sequence in the content
                (test "CRLF detection in DATA command" (lambda () 
                    (let
                        ((data-response (smtp-data smtp-connection "message content\r\n.\r\n")))
                        (assert-response-code data-response 250))))

                (test "handling server does not acknowledge data correctly" (lambda () 
                    (server-set-response-code! server "250")
                    (let
                        ((data-response (smtp-data smtp-connection "message content")))
                        (assert (smtp-error? data-response) "Expected client to fail when server does not acknowledge data correctly"))))

                ; Dot-quoting prevents stray dots at the beginning of lines to cause problems
                ; https://datatracker.ietf.org/doc/html/rfc2821#section-4.5.2
                ; Definition of line: https://datatracker.ietf.org/doc/html/rfc5321#section-2.3.8
                (data-test "DATA quotes dots at beginnings of lines"
                    '((".first line\r\n.second.line\r\n..third" 
                       "..first line\r\n..second.line\r\n...third\r\n.\r\n")
                      (".first line\n.second.line"
                       "..first line\r\n..second.line\r\n.\r\n"))
                    (lambda (sent-content received-content) (begin
                        (let
                            ((data-response (smtp-data smtp-connection sent-content)))
                            (assert-response-code data-response 250)
                            (assert-equal received-content (server-message-data server))))))

                )) 

            (capability 'rcpt (list
            
                (setup (lambda () 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection "")))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))


                (test "basic rcpt" (lambda () 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("user@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-last-request server "RCPT TO:<user@recipient.to>"))))

                (test "rcpt with special addresses" (lambda () 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("postmaster" "postmaster@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<postmaster>")
                        (assert-any-request server "RCPT TO:<postmaster@recipient.to>"))))

                (test "rcpt with multiple receivers" (lambda () 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("user@recipient.to" "user2@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<user@recipient.to>")
                        (assert-any-request server "RCPT TO:<user2@recipient.to>"))))

                (test "rcpt with invalid email address" (lambda ()
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("invalid") '())))
                        (assert-response-codes mail-responses 500))))

                (test "rcpt with options - DSN" (lambda ()
                    (server-set-extensions! server '("DSN"))
                    (let
                        ((mail-responses (smtp-rcpt 
                            smtp-connection 
                            '("user@recipient.to" 
                              "user2@recipient.to") 
                            '((("NOTIFY" ("SUCCESS" "FAILURE"))) 
                              (("NOTIFY" "NEVER"))))))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<user@recipient.to> NOTIFY=SUCCESS,FAILURE")
                        (assert-any-request server "RCPT TO:<user2@recipient.to> NOTIFY=NEVER"))))
                    
            ))

            (capability 'starttls (list
            
                (setup (lambda () 
                    (connect-smtp-server)))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (test "basic starttls" (lambda () 
                    (server-set-extensions! server '("STARTTLS"))
                    (smtp-ehlo smtp-connection "")
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '())))
                        (let-server-complete-handler)
                        (assert-response-code starttls-response 220)
                        (assert (server-tls-started? server) "Sending STARTTLS should result in a successful TLS connection on the server."))))

                (test "starttls without server support" (lambda () 
                    (server-set-extensions! server '())
                    (smtp-ehlo smtp-connection "")
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '())))
                        (assert (smtp-extension-not-supported-error? starttls-response)
                                (string-append "Expected \"" starttls-response "\" to be an unsupported SMTP extension error"))
                        (assert (not (server-tls-started? server))))))

                ; RFC 3207 - 4.2
                (test "After starttls extensions need to be refetched" (lambda () 
                    (server-set-extensions! server '("STARTTLS"))
                    (smtp-ehlo smtp-connection "")
                    (server-set-extensions! server '("FUNKY" "FOO"))
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '()))
                         (ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-extensions smtp-connection ehlo-response '("FUNKY" "FOO")))))
                  
            ))

            ; 'automatic-starttls applies when the library supports automatically upgrading
            ; a connection to TLS when the server supports it
            (capability 'automatic-starttls (list
            
                (test "automatic starttls active and server supports starttls" (lambda ()
                    (server-set-extensions! server '("STARTTLS"))
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'automatic)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (server-tls-started? server))))))

                (test "automatic starttls active and server does not support starttls" (lambda ()
                    (server-set-extensions! server '())
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'automatic)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server)))))))

                (test "automatic starttls not active and server does support starttls" (lambda ()
                    (server-set-extensions! server '("STARTTLS"))
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'never)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server)))))))

                (test "automatic starttls not active and server does not support starttls" (lambda ()
                    (server-set-extensions! server '())
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'never)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server)))))))

                ; 'required-starttls covers modes in which starttls should always be used and the connection
                ; should be terminated in case the server does not support it
                (capability 'required-starttls (list 

                    (test "required starttls active and server supports starttls" (lambda ()
                        (server-set-extensions! server '("STARTTLS"))
                        (let 
                            ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'required)))
                            (let 
                                ((ehlo-response (smtp-ehlo connection "")))
                                (assert-response-code echo-response 220)
                                (assert (server-tls-started? server))))))

                    (test "required starttls active and server does not support starttls" (lambda ()
                        (server-set-extensions! server '())
                        (let 
                            ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'required)))
                            (assert (smtp-error? connection))
                            (assert (server-tls-started? server)))))
                        
                ))
            ))

            (capability 'auth (list

                (define (connect-and-ehlo-smtp-server) 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))

                (tearDown (lambda () 
                    (smtp-disconnect smtp-connection)))

                (data-test "other auth failures" 
                    '(("454 4.7.0  Temporary authentication failure" #t)
                    ("534 5.7.9  Authentication mechanism is too weak" #t)
                    ("538 5.7.11  Encryption required for requested authentication mechanism" #t)
                    ("500 5.5.6  Authentication Exchange line is too long" #t)
                    ("503 5.5.1 Error: authentication not enabled" #f) )
                    (lambda (response auth-enabled) (begin 
                        (if auth-enabled (server-set-auths! server '((PLAIN ("account" "password")))))
                        (connect-and-ehlo-smtp-server)
                        (server-set-response-code! server response)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN (list "account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)) (string-append "Expected auth failure for " response " but got " auth-result))))))
                    

                (capability 'plain-auth (list 

                    (define (plain-auth-proc credentials connection success failure)
                        (let 
                            ((credentials (if (not (= credentials ""))
                                credentials
                                (begin 
                                    (socket-write connection "334 \r\n")
                                    (string-trim (socket-receive connection))))))
                            (if (= credentials "AGFjY291bnQAcGFzc3dvcmQ=")
                                (success)
                                (failure))))

                    (setup (lambda () 
                        (server-set-auth-proc! server plain-auth-proc)))

                    (test "plain auth success" (lambda ()
                        (server-set-auths! server '((PLAIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'PLAIN (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result)))))

                    (test "plain auth unsuccessful" (lambda () 
                        (server-set-auths! server '((PLAIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN '("account" "foo"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) "Expected credentials error"))))

                    (test "plain auth not supported" (lambda () 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN '("account" "foo"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result)))))

                    (capability 'initial-response (list

                        (test "plain auth with initial response" (lambda ()
                            (server-set-auths! server '((PLAIN ("account" "password"))))
                            (connect-and-ehlo-smtp-server)
                            (let 
                                ((auth-result 
                                    (smtp-authenticate-initial-response smtp-connection 'PLAIN '("account" "password") #t)))
                                (assert (smtp-auth-successful? auth-result)))))

                    ))

                ))

                ; TODO: Implement initial response false and true tests
                (capability 'xoauth2 (list 

                    (define (xoauth2-auth-proc credentials connection success failure)
                        (if (= credentials "dXNlcj1hY2NvdW50AWF1dGg9QmVhcmVyIHRva2VuAQE=")
                            (success)
                            (failure)))

                    (setup (lambda () 
                        (server-set-auth-proc! server xoauth2-auth-proc)))

                    (test "xoauth2 success" (lambda ()
                        (server-set-auths! server '((XOAUTH2 ("account" "token"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'XOAUTH2 (list "account" "token"))))
                            (assert (smtp-auth-successful? auth-result)))))

                    (test "xoauth2 auth unsuccessful" (lambda () 
                        (server-set-auths! server '((XOAUTH2 ("account" "token"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'XOAUTH2 '("account" "not-a-token"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result)))))

                    (test "xoauth2 auth not supported" (lambda () 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'XOAUTH2 '("account" "token"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result)))))

                ))

                (capability 'cram-md5 (list 

                    (define (cram-md5-auth-proc credentials connection success failure)
                        (if (= credentials "")
                            (begin
                                (socket-write connection "334 PDEyMzQ1Njc4OTAuMTIzNDVAc2VydmVybmFtZT4=\r\n")
                                (let 
                                    ((cram-md5-response (string-trim (socket-receive connection))))
                                    (if (= cram-md5-response "YWNjb3VudCAyYzBjMTgxZjkxOGU2ZGM5Mjg3Zjk3N2E1ODhiMzg1YQ==")
                                        (success)
                                        (failure))))
                            (failure)))

                    (setup (lambda () 
                        (server-set-auth-proc! server cram-md5-auth-proc)))

                    (test "cram-md5 success" (lambda ()
                        (server-set-auths! server '((CRAM-MD5 ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'CRAM-MD5 (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result)))))

                    (test "cram-md5 auth unsuccessful" (lambda () 
                        (server-set-auths! server '((CRAM-MD5 ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'CRAM-MD5 '("account" "not-the-password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result)))))

                    (test "cram-md5 auth not supported" (lambda () 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'CRAM-MD5 '("account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result)))))

                    (capability 'initial-response (list

                        (test "cram-md5 initial response not supported and should be ignored" (lambda ()
                            ; Test would fail, as mock auth procedure fails when inital response is provided
                            (server-set-auths! server '((CRAM-MD5 ("account" "password"))))
                            (connect-and-ehlo-smtp-server)
                            (let 
                                ((auth-result 
                                    (smtp-authenticate-initial-response smtp-connection 'CRAM-MD5 '("account" "password") #t)))
                                (assert (smtp-auth-successful? auth-result)))))

                    ))
                ))


                (capability 'login (list 

                    (define (login-auth-proc credentials connection success failure)
                        (let 
                            ((login-user-response
                                (if (not (= credentials "")) 
                                    credentials
                                    (begin
                                        (socket-write connection "334 VXNlcm5hbWU6\r\n")
                                        (string-trim (socket-receive connection))))))
                            (socket-write connection "334 UGFzc3dvcmQ6\r\n")
                            (let 
                                ((login-password-response (string-trim (socket-receive connection)))) 
                                (if (and (= login-user-response "YWNjb3VudA==") (= login-password-response "cGFzc3dvcmQ="))
                                    (success)
                                    (failure)))))

                    (setup (lambda () 
                        (server-set-auth-proc! server login-auth-proc)))

                    (test "login success" (lambda ()
                        (server-set-auths! server '((LOGIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'LOGIN (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result)))))

                    (test "login auth unsuccessful" (lambda () 
                        (server-set-auths! server '((LOGIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'LOGIN '("account" "not-the-password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result)))))

                    (test "login auth not supported" (lambda () 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'LOGIN '("account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result)))))

                    (capability 'initial-response (list

                        (test "login initial response" (lambda ()
                            (server-set-auths! server '((LOGIN ("account" "password"))))
                            (connect-and-ehlo-smtp-server)
                            (let 
                                ((auth-result 
                                    (smtp-authenticate-initial-response smtp-connection 'LOGIN '("account" "password") #t)))
                                (assert (smtp-auth-successful? auth-result)))))

                    ))

                ))

                (capability 'buggy-auths (list
                
                    (define (buggy-auth-proc credentials connection success failure)
                        (define (looping-auth count)
                            (if (> count 0)
                                (begin
                                    (socket-write connection "334 VXNlcm5hbWU6\r\n")
                                    (looping-auth (- count 1))))
                        (looping-auth 10)))

                    (setup (lambda () 
                        (server-set-auth-proc! server buggy-auth-proc)))

                    (test "buggy auth with too many challenges" (lambda ()
                        (server-set-auths! server '((BUGGY ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'BUGGY (list "account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result))))))
                
                ))

            ))

            (capability 'quit (list
            
                (test "quit resets list of extensions, if it is stored in the connection" (lambda ()
                    (begin
                        (server-set-extensions! server '("8BITMIME"))
                        (connect-smtp-server)
                        (smtp-ehlo smtp-connection "")
                        (smtp-quit smtp-connection)
                        (assert-extensions smtp-connection '() '()))))

            ))

        ))

    )
)