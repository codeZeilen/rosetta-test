(suite 
	"SMTP" "0.1"
    (sources 
		'("CPython SMTP tests" "Python Foundation" "https://github.com/python/cpython/blob/9ba2a4638d7b620c939face7642b2f53a9fadc4b/Lib/test/test_smtplib.py")
        '("Ruby net-smtp tests" "MRI maintainers" "https://github.com/ruby/net-smtp/blob/master/test/net/smtp/test_smtp.rb")
        '("SMTP RFC 2821" "IETF" "https://tools.ietf.org/html/rfc2821")
        '("SMTP RFC 5321" "IETF" "https://tools.ietf.org/html/rfc5321")
        '("SMTP RFC 4954" "IETF" "https://tools.ietf.org/html/rfc4954"))
    
    (list 
        (placeholder '(create-socket) "Create a local network socket for the server to communicate through (it should already listen for new connections)")
        (placeholder '(socket-receive socket) "Read trimmed data from socket")
        (placeholder '(socket-write socket data) "Write data to socket")
        (placeholder '(socket-port socket) "Return the port of the socket")
        (placeholder '(socket-accept socket) "Accept a new connection on the socket")
        (placeholder '(socket-close socket) "Close the socket")

        (placeholder '(secure-server-socket-wrap socket ca-file cert-file key-file close-underlying-socket) "Should wrap an existing connected server socket with a secure socket (TLS/SSL) with the given configuration. Then the procedure should wait for the handshake (accept) to complete.")

        (placeholder '(smtp-connect host port) "Should connect and return some representation of the connection.")
        (placeholder '(smtp-connect-with-auto-starttls host port starttls-mode) "Should connect and set the automatic starttls mode (which can be 'automatic (send starttls if available, otherwise do not), 'required (connect and send starttls, fail if server does not support it), 'never (do not automatically send starttls)). In case the connection results in an error (e.g. starttls mode is 'required but server does not support starttls), the error should be returned.")
        (placeholder '(smtp-secure-connect host port ca-file) "Should connect to an SMTP server via a secure connection (SSL/TLS) and return some representation of the connection.")
        (placeholder '(smtp-secure-connect-with-timeout host port ca-file timeout) "Same as smtp-secure-connect but the connection should be aborted if the handshake does not complete within the timeout.")
        (placeholder '(smtp-disconnect connection) "Should close the connection")
        (placeholder '(smtp-send-message-with-options connection message-content from to-list message-options to-list-options) "Send a message to the server. The message-options and the to-list-options are optional. The to-list-options is a list of option tuple lists, one for each receiver. The function should return a list corresponding to the responses from the server for each recipient in the to-list. If there is only a single response, a list with a single response should be returned.")
        (define (smtp-send-message connection content from to-list)
            (smtp-send-message-with-options connection content from to-list  '() '()))
        (placeholder '(smtp-ehlo connection content) "Send an EHLO command to the server")
        (placeholder '(smtp-mail-with-options connection from options) "Send a MAIL command to the server, supplying optional options (provided as a list of strings, that can be joined using compile-options-string if necessary).")
        (define (smtp-mail connection from) 
            (smtp-mail-with-options connection from '()))
        (placeholder '(smtp-rcpt connection to-list options-list) "Send a RCPT command to the server. The to parameter should be a list of recipients. The function should return a list of responses from the server. Whether the RCPT commands are send by multiple invocations or a single one can be decided by the placeholder. The options list contains lists of options, one list of options per receipient. The list of options contains tuples with the option name as the first element, and the option value as the second. Clients may use the functions compile-options-strings, compile-options-string, and compile-option-string to compile the options list into key-value-strings that can be sent to the server.")
        (placeholder '(smtp-rset connection) "Send a RST command to the server")
        (placeholder '(smtp-starttls connection cert-file key-file) "Send a STARTTLS command to the server. The cert-file and key-file are optional.")
        (placeholder '(smtp-data connection content) "Send a DATA command to the server for transmitting the content. The content should be a string and not contain the SMTP data terminating sequence.")
        (placeholder '(smtp-error? response) "Returns true if the response represents an error of some kind. This does not include error responses from the server but rather errors in the client-server communication.")
        (placeholder '(smtp-response-code response) "Return the response code from the server")
        (placeholder '(smtp-response-message response) "Return the response message from the server")
        (placeholder '(smtp-extensions connection ehlo-response) "Return a list of extensions of the server, either from the connection or the ehlo response") ; This is already an interesting case, as the extensions may be derived from only a response or may be a property of the connection object
        (placeholder '(smtp-extension-not-supported-error? response) "Did the command fail due to an unsupported extension?")
        (placeholder '(smtp-authenticate connection method credentials) "Run authentication and return the result (in case of an exception return exception object or a stand-in for the exception)")
        (placeholder '(smtp-auth-successful? "Was the authentication successful?"))
        ; The following two are also interesting as this is an advanced feature that might be moved to a dedicated capability, but then it shares the same situation as the other unsuccessful auth tests
        (placeholder '(smtp-auth-credentials-error? "Did the authentication fail due to wrong credentials?")) 
        (placeholder '(smtp-auth-not-supported-error? "Did the authentication fail due to no compatible authentication method?"))

        (define server '())
        (define (server-thread server) (list-ref server 1))
        (define (server-socket server) (list-ref server 2))
        (define (server-port server) (socket-port (list-ref server 2)))
        (define (server-stopped? server) (list-ref server 3))
        (define (server-extensions server) (list-ref server 4))
        (define (server-response-code server) (list-ref server 5))
        (define (server-auths server) (list-ref server 6))
        (define (server-requests server) (list-ref server 7))
        (define (server-tls? server) (list-ref server 8))
        (define (server-tls-started? server) (list-ref server 9)) ; Was a TLS connection started via STARTTLS?
        (define (server-auth-proc server) (list-ref server 10))

        (define (server-set-thread! server new-thread) 
            (list-set! server 1 new-thread))
        (define (server-set-socket! server new-socket) 
            (list-set! server 2 new-socket))
        (define (server-set-extensions! server new-extensions) 
            (list-set! server 4 new-extensions))
        (define (server-set-response-code! server new-code) 
            (list-set! server 5 new-code))
        (define (server-set-auths! server new-auths) 
            (list-set! server 6 new-auths))
        (define (server-set-requests! server new-requests) 
            (list-set! server 7 new-requests))
        (define (server-enable-tls server) 
            (list-set! server 8 #t))
        (define (server-disable-tls server) 
            (list-set! server 8 #f))
        (define (server-set-tls-started! server boolean) 
            (list-set! server 9 boolean))
        (define (server-set-auth-proc! server proc)
            (list-set! server 10 proc))

        (define (server-extensions-with-auth server) 
            (if (empty? (server-auths server))
                (server-extensions server)
                (append 
                    (server-extensions server)
                    (list (fold-left 
                        (lambda (acc auth-name) (string-append acc " " auth-name))
                        "AUTH"
                        (map
                            (lambda (auth) (car auth))
                            (server-auths server)))))))
        (define (server-auth-methods server)
            (map 
                car
                (server-auths server)))
        (define (server-has-response-code? server) (not (= (server-response-code server) "0")))
        (define (let-server-complete-handler)
            (thread-sleep! 0.1))
        
        (define (create-server tls-enabled) (list 'server '() '() #f '() "0" '() '() tls-enabled #f (lambda (credentials connection success failure) '())))
        (define (server-stop server) (list-set! server 3 #t))
        (define (server-start server)
            (let 
                ((socket (create-socket)))
                (server-set-socket!
                    server
                    socket)
                (server-set-thread! 
                    server
                    (thread (lambda () 
                        (run-mock-smtp-server server))))
                server))

        (define (start-mock-server)
            (server-start (create-server #f)))
        (define (stop-mock-server) (begin
            (server-stop server)
            (thread-wait-for-completion (server-thread server))))

        (define (run-mock-smtp-server server)
            (begin
                (define CA_FILE "./smtp-fixtures/cacert.pem")
                (define CERT_FILE "./smtp-fixtures/server.pem")
                (define KEY_FILE "./smtp-fixtures/server.key")
                (define connection '())
                (define (init) (begin 
                    (set! 
                        connection 
                        (if (server-tls? server)
                            (secure-server-socket-wrap (socket-accept (server-socket server)) CA_FILE CERT_FILE KEY_FILE #t) 
                            (socket-accept (server-socket server))))
                    (if (null? connection)
                        #f
                        (begin 
                            (socket-write connection "220 OK\r\n")
                            #t))))
                (define (close-sockets) (begin 
                    (socket-close connection)
                    (socket-close (server-socket server))))
                (define (handle request-string) (begin
                    ; Log the request
                    (server-set-requests! 
                        server 
                        (append (server-requests server) (list request-string)))
                    ; Handle the request
                    (let
                        ((command (string-upcase (request-command request-string)))
                         (args (request-arguments request-string)))
                        (if (server-has-response-code? server)
                            (socket-write connection (string-append (server-response-code server) "\r\n"))
                            (cond 
                                ((= command "EHLO") (ehlo (car args)))
                                ((= command "AUTH") (auth args))
                                ((= command "MAIL") (mail args))
                                ((= command "RCPT") (rcpt args))
                                ((= command "DATA") (data-command args))
                                ((= command "STARTTLS") (starttls args))
                                (else (error "Command not found")))))))                
                (define (loop) (let 
                    ((request-string (socket-receive connection)))
                    (if (empty? request-string)
                        (close-sockets)
                        (begin
                            (handle request-string)
                            (if (server-stopped? server)
                                (close-sockets)
                                (loop))))))
                (define (mail args)
                    (if (or (empty? args) (= (second (string-split (car args) ":")) "<invalid>"))
                        (socket-write connection "500\r\n")
                        (socket-write connection "250 2.1.0 OK\r\n")))
                (define (rcpt args)
                    (if (or (empty? args) (= (second (string-split (car args) ":")) "<invalid>"))
                        (socket-write connection "500\r\n")
                        (socket-write connection "250 2.1.0 OK\r\n")))
                (define (data-command args)
                    (begin 
                        (socket-write connection "354 End data with <CR><LF>.<CR><LF>\r\n")
                        (let 
                            ((message-data (socket-receive connection))) 
                            (socket-write connection "250 2.0.0 OK\r\n"))))
                (define (starttls args)
                    (socket-write connection "220 Ready to start TLS\r\n")
                    (let 
                        ((secure-socket (secure-server-socket-wrap connection CA_FILE CERT_FILE KEY_FILE #t)))
                        (server-set-tls-started! server #t)
                        (set! connection secure-socket)))
                (define (auth args)
                    (define (write-auth-failure-response) 
                        (socket-write connection "535 5.7.8  Authentication credentials invalid\r\n"))
                    (define (write-auth-success-response) 
                        (socket-write connection "235 2.7.0 Authentication successful\r\n"))
                    (let 
                        ((method (string-upcase (car args)))
                         (credentials (if (> (length args) 1) (second args) "")))
                        (if (and 
                                (member method '("PLAIN" "LOGIN" "XOAUTH2" "CRAM-MD5")) ; Check whether we support auth method at all
                                (member method (server-auth-methods server))) ; Check whether auth method is listed
                            ((server-auth-proc server) 
                                credentials 
                                connection
                                write-auth-success-response 
                                write-auth-failure-response)
                            ; else case to capture non-supported methods early RFC 4954 - Section 4
                            (socket-write connection "504 5.5.4 Command not implemented\r\n"))))
                (define (ehlo answer) 
                    (define (replace-last list element) (reverse (cons element (cdr (reverse list)))))
                    (let 
                        ((answers (fold-left 
                            (lambda (acc extension)
                                (append acc (list (string-append "250-" extension "\r\n"))))
                            (list (string-append "250-" answer "\r\n"))
                            (server-extensions-with-auth server))))
                        (let 
                            ((answers-text (string-join 
                                (replace-last 
                                    answers
                                    (string-replace "250-" "250 " (last answers)))))) 
                            (socket-write 
                                connection 
                                answers-text))))

                (if (init) (loop))))

        ; Get command from a request
        (define (request-command request) (string-trim (car (string-split request " "))))

        ; Get arguments from a request
        (define (request-arguments request) (map string-trim (cdr (string-split request " "))))

        ; Compile one option to a string, either from a tuple (KEY VALUE|VALUES) to "KEY=VALUE,VALUE"
        ; or if already a string, simply return it.
        (define (compile-option-string option)
            (if (list? option)
                (string-append 
                    (first option)
                    "="
                    (if (list? (last option)) 
                        (string-join (last option) ",") 
                        (last option)))
                ; If not a list, just retrun
                option))

        ; Compile a list of option tuples to a list of strings
        (define (compile-options-strings options) 
            (map compile-option-string options))

        ; Compile a list of option strings to a single string that can be sent to the server
        (define (compile-options-string options) 
            (string-join (compile-options-strings options) " "))

        (define (assert-response-code response code) (assert-equal code (smtp-response-code response)))
        (define (assert-response-codes responses code) (
            for-each 
                (lambda (response) (assert-response-code response code))
                responses))

        (define (assert-extensions server response extensions) (= extensions (smtp-extensions server response)))

        ; Tests whether request 1 corresponds to request 2 (ignoring case)
        (define (request-equal? request1 request2)
            (let
                ((request1-command (string-upcase (request-command request1)))
                    (request1-arguments (request-arguments request1))
                    (request2-command (string-upcase (request-command request2)))
                    (request2-arguments (request-arguments request2)))
                (and 
                    (= request1-command request2-command)
                    (= request1-arguments request2-arguments))))

        ; Asserts whether the last request matches the given one ignoring case for the command part
        (define (assert-last-request server request) 
            (assert (request-equal? (last (server-requests server)) request)))

        (define (server-includes-request server request) 
            (not (empty? (filter 
                    (lambda (req) (request-equal? req request)) 
                    (server-requests server)))))

        (define (assert-any-request server request) 
            (assert 
                (server-includes-request server request) 
                (string-append "Expected request " request " but got " (server-requests server))))

        (setup (lambda () (begin 
            (set! server '()))))

        (tearDown (lambda () (begin 
            (stop-mock-server))))

        ;
        ; Capabilities
        ;

        (capability 'connection (list

            (setup (lambda () (begin 
                (set! server (start-mock-server)))))

            (test "Connect to server" (lambda () (begin 
                (smtp-connect "localhost" (server-port server)))))

        ))

        (capability 'tls-connection (list

            (define original-secure-server-socket-wrap '())

            (define start-tls-mock-server (lambda () (begin 
                (set! server (server-start (create-server #t))))))

            (tearDown (lambda () (begin
                (if (not (= original-secure-server-socket-wrap '()))
                    (begin
                        (set! secure-server-socket-wrap original-secure-server-socket-wrap)
                        (set! original-secure-server-socket-wrap '()))))))

            (test "Connect to server with TLS" (lambda () (begin 
                (start-tls-mock-server)
                (smtp-secure-connect "localhost" (server-port server) "./smtp-fixtures/cacert.pem"))))

            (test "Timeout during connect to server with TLS" (lambda () (begin
                (set! original-secure-server-socket-wrap secure-server-socket-wrap)
                (set! secure-server-socket-wrap (lambda (socket x xx xxx xxxx) (begin 
                    (thread-sleep! 0.5)
                    (socket-close socket))))
                (start-tls-mock-server)
                (assert (smtp-error? (smtp-secure-connect-with-timeout "localhost" (server-port server) "./smtp-fixtures/cacert.pem" 0.1))))))
            
        ))

        (capability 'crlf-injection-detection (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () (begin 
                (set! server (start-mock-server))
                (connect-smtp-server)
                (smtp-ehlo smtp-connection ""))))

            (tearDown (lambda () (begin 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '()))))


            (capability 'commands (list

                (data-test "CRLF detection in MAIL command"
                    '(("foo\r\nbar") ("foo\nbar") ("foo\rbar")) 
                    (lambda (sender-string) (begin 
                        (let
                            ((mail-response (smtp-mail smtp-connection sender-string)))
                            (assert (smtp-error? mail-response) (string-append "Expected client to fail when CR or LF is in MAIL command: " sender-string))))))

                (data-test "CRLF detection in RCPT command"
                    '(("foo\r\nbar") ("foo\nbar") ("foo\rbar")) 
                    (lambda (recipient-string) (begin 
                        (let
                            ((mail-response (first (smtp-rcpt smtp-connection (list recipient-string) '()))))
                            (assert (smtp-error? mail-response) (string-append "Expected client to fail when CR or LF is in RCPT command: " recipient-string))))))
            
            ))

            (capability 'send-message (list

                (data-test "CRLF detection in send-message sender"
                    '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                    (lambda (sender-string) (begin 
                        (let
                            ((responses (smtp-send-message smtp-connection "message content" sender-string '("user@recipient.to"))))
                            (display responses)
                            (assert (all? smtp-error? responses) (string-append "Expected client to fail when CR or LF is in sender of send-message: " sender-string))))))
                        
                (data-test "CRLF detection in send-message recipient"
                    '(("foo\r\nbar@email.com") ("foo\nbar@email.com") ("foo\rbar@email.com")) 
                    (lambda (recipient-string) (begin 
                        (let
                            ((responses (smtp-send-message smtp-connection "message content" "sender@email.com" (list recipient-string))))
                            (assert (all? smtp-error? responses) (string-append "Expected client to fail when CR or LF is in recipient of send-message: " recipient-string))))))
            
            ))
                    
        ))

        ; This covers full scenarios for sending a message that may be covered by convenience functions or
        ; require bridge implementors to use the commands directly
        (capability 'send-message (list

            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () (begin 
                (set! server (start-mock-server))
                (connect-smtp-server)
                (smtp-ehlo smtp-connection ""))))

            (tearDown (lambda () (begin 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '()))))

            (test "Send a message" (lambda () (let
                ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                (assert-response-codes response 250))))

            (test "Send a message to multiple recipients" (lambda () (let
                ((response (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user1@recipient.to" "user2@recipient.to"))))
                (assert-response-codes response 250))))

            (data-test "Failures during send message" 
                '(("400 BUSY" 400)
                ("502 SYNTAX ERROR" 502)
                ("530 AUTH ERROR" 530)
                ("520 FATAL ERROR" 520)
                ("300 UNKNOWN" 300) )
                (lambda (response response-code) (begin 
                    (server-set-response-code! server response)
                    (let
                        ((response 
                            (smtp-send-message smtp-connection "message content" "sender@sender.to" '("user@recipient.to"))))
                        (assert-response-codes response response-code)))))

        ))

        (capability 'smtputf8 (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () (begin 
                (set! server (start-mock-server))
                (connect-smtp-server))))

            (tearDown (lambda () (begin 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '()))))

            ; RFC 6531 3.1 - Item 8
            (define (activate-smtputf8 server) 
                (server-set-extensions! server '("SMTPUTF8" "8BITMIME")))

            (capability 'mail (list

                (capability 'mandatory-options (list
                    (test "International mailbox in mail without SMTPUTF8 support" (lambda () (begin
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("SMTPUTF8"))))
                            (assert (smtp-error? mail-response))))))

                    (test "International mailbox in mail without SMTPUTF8 support and no option" (lambda () (begin
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '())))
                            (assert (smtp-error? mail-response))))))

                    (test "international mailbox in mail with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("SMTPUTF8"))))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8")))))

                    (test "international mailbox in mail with SMTPUTF8 support but no option" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '())))
                            (assert (smtp-error? mail-response))))))
                ))

                (capability 'automatic-smtputf8-detection (list
                    (test "International mailbox in mail without SMTPUTF8 support" (lambda () (begin
                        (server-set-extensions! server '())
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail smtp-connection "χρήστης@παράδειγμα.ελ")))
                            (assert (smtp-error? mail-response))))))

                    (test "international mailbox in mail with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail smtp-connection "χρήστης@παράδειγμα.ελ")))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8")))))    

                    (test "international mailbox in mail with SMTPUTF8 support and explicit option" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((mail-response (smtp-mail-with-options smtp-connection "χρήστης@παράδειγμα.ελ" '("8BITMIME"))))
                            (assert-response-code mail-response 250)
                            (assert-last-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> 8BITMIME SMTPUTF8")))))
                ))
            ))

            (capability 'rcpt (list
                ; No test with server without SMTPUTF8 support, as the smtp-mail command would
                ; already fail to initiate a mail transaction.

                (test "international mailbox in rcpt with SMTPUTF8 support" (lambda () (begin
                    (activate-smtputf8 server)
                    (smtp-ehlo smtp-connection "")
                    (smtp-mail-with-options smtp-connection "sender@sender.com" '("SMTPUTF8"))
                    (let
                        ((rcpt-response (smtp-rcpt smtp-connection '("χρήστης@παράδειγμα.ελ") '())))
                        (assert-response-codes rcpt-response 250)
                        (assert-last-request server "RCPT TO:<χρήστης@παράδειγμα.ελ>")))))

                (test "international mailbox in rcpt with SMTPUTF8 support but no option" (lambda () (begin
                    (activate-smtputf8 server)
                    (smtp-ehlo smtp-connection "")
                    (smtp-mail-with-options smtp-connection "sender@sender.com" '())
                    (let
                        ((rcpt-response (smtp-rcpt smtp-connection '("χρήστης@παράδειγμα.ελ") '())))
                        (assert (smtp-error? rcpt-response))))))
            ))

            (capability 'send-message (list
            
                (capability 'mandatory-options (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert (smtp-error? send-message-response))))))

                    (test "international recipient mailbox in send-message without SMTPUTF8 support and no option" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (smtp-error? send-message-response))))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '("SMTPUTF8") '())))
                            (assert-response-codes send-message-response 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8")))))

                    (test "international recipient mailbox in send-message with SMTPUTF8 support but no option" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ") '() '())))
                            (assert (smtp-error? send-message-response))))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert (smtp-error? send-message-response))))))

                    (test "international sender mailbox in send-message without SMTPUTF8 support and no option" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (smtp-error? send-message-response))))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '("SMTPUTF8") '())))
                            (assert-response-codes send-message-response 250)
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8")))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support but no option" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message-with-options 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com") '() '())))
                            (assert (smtp-error? send-message-response))))))
                ))

                (capability 'automatic-smtputf8-detection (list

                    ; Recipient

                    (test "international recipient mailbox in send-message without SMTPUTF8 support" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert (smtp-error? send-message-response))))))  

                    (test "international recipient mailbox in send-message with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message 
                                smtp-connection "message content" "sender@sender.com" '("χρήστης@παράδειγμα.ελ"))))
                            (assert-response-codes send-message-response 250)
                            (assert-any-request server "MAIL FROM:<sender@sender.com> SMTPUTF8")))))

                    ; Sender

                    (test "international sender mailbox in send-message without SMTPUTF8 support" (lambda () (begin
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert (smtp-error? send-message-response))))))

                    (test "international sender mailbox in send-message with SMTPUTF8 support" (lambda () (begin
                        (activate-smtputf8 server)
                        (smtp-ehlo smtp-connection "")
                        (let
                            ((send-message-response (smtp-send-message 
                                smtp-connection "message content" "χρήστης@παράδειγμα.ελ" '("recipient@server.com"))))
                            (assert-response-codes send-message-response 250)
                            (assert-any-request server "MAIL FROM:<χρήστης@παράδειγμα.ελ> SMTPUTF8")))))
                ))

            ))

        ))

        (capability 'commands (list
        
            (define smtp-connection '())
            (define (connect-smtp-server)
                (set! smtp-connection (smtp-connect "localhost" (server-port server))))

            (setup (lambda () (begin
                (set! server (start-mock-server)))))

            (tearDown (lambda () (begin 
                (smtp-disconnect smtp-connection)
                (set! smtp-connection '()))))

            (capability 'ehlo (list
                (setup (lambda () (begin 
                    (connect-smtp-server))))

                (test "basic ehlo" (lambda () (begin 
                    (smtp-ehlo smtp-connection ""))))
                    
                (test "ehlo with identifier" (lambda () (begin 
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "553.231.231.234")))
                        (assert-equal
                            250
                            (smtp-response-code ehlo-response))
                        (assert-equal
                            "553.231.231.234"
                            (smtp-response-message ehlo-response))
                        ))))

                (test "server answers a single extension" (lambda () (begin
                    (server-set-extensions! server (list "8BITMIME"))
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250)
                        (assert-extensions smtp-connection ehlo-response (list "8BITMIME"))))))

                (test "server answers multiple extensions" (lambda () (begin
                    (server-set-extensions! server (list "8BITMIME" "VERB"))
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 250)
                        (assert-extensions smtp-connection ehlo-response (list "8BITMIME" "VERB"))))))

                (test "server answers ehlo with error code" (lambda () (begin
                    (server-set-response-code! server "550 not message")
                    (let
                        ((ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-response-code ehlo-response 550)))))

                ))

            (capability 'rset (list
            
                (setup (lambda () (begin 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))

                (test "basic rset" (lambda () (begin
                    (server-set-response-code! server "250")
                    (let
                        ((rset-response (smtp-rset smtp-connection)))
                        (assert-response-code rset-response 250)))))

                ))

            (capability 'mail (list
            
                (setup (lambda () (begin 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))

                (test "basic mail" (lambda () (begin 
                    (let
                        ((mail-response (smtp-mail smtp-connection "foo@example.com")))
                        (assert-response-code mail-response 250)))))

                ; RFC 2476 - 3.2
                (test "mail with empty email address" (lambda () (begin 
                    (let
                        ((mail-response (smtp-mail smtp-connection "")))
                        (assert-response-code mail-response 250)
                        (assert-last-request server "MAIL FROM:<>")))))

                (test "mail with invalid email address" (lambda () (begin 
                    (let
                        ((mail-response (smtp-mail smtp-connection "invalid")))
                        (assert-response-code mail-response 500)))))

                ))

            (capability 'data (list
            
                (setup (lambda () (begin 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))

                (test "basic data" (lambda () (begin 
                    (let
                        ((data-response (smtp-data smtp-connection "message content")))
                        (assert-response-code data-response 250)))))

                ; Client should not be confused by an accidental message content termination sequence in the content
                (test "CRLF detection in DATA command" (lambda () (begin 
                    (let
                        ((data-response (smtp-data smtp-connection "message content\r\n.\r\n")))
                        (assert-response-code data-response 250)))))

                (test "handling server does not acknowledge data correctly" (lambda () (begin 
                    (server-set-response-code! server "250")
                    (let
                        ((data-response (smtp-data smtp-connection "message content")))
                        (assert (smtp-error? data-response) "Expected client to fail when server does not acknowledge data correctly")))))

                )) 

            (capability 'rcpt (list
            
                (setup (lambda () (begin 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))


                (test "basic rcpt" (lambda () (begin 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("user@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-last-request server "RCPT TO:<user@recipient.to>"))))) 

                (test "rcpt with special addresses" (lambda () (begin 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("postmaster" "postmaster@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<postmaster>")
                        (assert-any-request server "RCPT TO:<postmaster@recipient.to>")))))

                (test "rcpt with multiple receivers" (lambda () (begin 
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("user@recipient.to" "user2@recipient.to") '())))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<user@recipient.to>")
                        (assert-any-request server "RCPT TO:<user2@recipient.to>")))))

                (test "rcpt with invalid email address" (lambda () (begin
                    (let
                        ((mail-responses (smtp-rcpt smtp-connection '("invalid") '())))
                        (assert-response-codes mail-responses 500)))))

                (test "rcpt with options - DSN" (lambda () (begin
                    (server-set-extensions! server '("DSN"))
                    (let
                        ((mail-responses (smtp-rcpt 
                            smtp-connection 
                            '("user@recipient.to" 
                              "user2@recipient.to") 
                            '((("NOTIFY" ("SUCCESS" "FAILURE"))) 
                              (("NOTIFY" "NEVER"))))))
                        (assert-response-codes mail-responses 250)
                        (assert-any-request server "RCPT TO:<user@recipient.to> NOTIFY=SUCCESS,FAILURE")
                        (assert-any-request server "RCPT TO:<user2@recipient.to> NOTIFY=NEVER")))))
                    
            ))

            (capability 'starttls (list
            
                (setup (lambda () (begin 
                    (connect-smtp-server))))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))

                (test "basic starttls" (lambda () (begin 
                    (server-set-extensions! server '("STARTTLS"))
                    (smtp-ehlo smtp-connection "")
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '())))
                        (let-server-complete-handler)
                        (assert-response-code starttls-response 220)
                        (assert (server-tls-started? server) "Sending STARTTLS should result in a successful TLS connection on the server.")))))

                (test "starttls without server support" (lambda () (begin 
                    (server-set-extensions! server '())
                    (smtp-ehlo smtp-connection "")
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '())))
                        (assert (smtp-extension-not-supported-error? starttls-response))
                        (assert (not (server-tls-started? server)))))))

                ; RFC 3207 - 4.2
                (test "After starttls extensions need to be refetched" (lambda () (begin 
                    (server-set-extensions! server '("STARTTLS"))
                    (smtp-ehlo smtp-connection "")
                    (server-set-extensions! server '("FUNKY" "FOO"))
                    (let
                        ((starttls-response (smtp-starttls smtp-connection '() '()))
                         (ehlo-response (smtp-ehlo smtp-connection "")))
                        (assert-extensions smtp-connection ehlo-response '("FUNKY" "FOO"))))))
                  
            ))

            ; 'automatic-starttls applies when the library supports automatically upgrading
            ; a connection to TLS when the server supports it
            (capability 'automatic-starttls (list
            
                (test "automatic starttls active and server supports starttls" (lambda () (begin
                    (server-set-extensions! server '("STARTTLS"))
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'automatic)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (server-tls-started? server)))))))

                (test "automatic starttls active and server does not support starttls" (lambda () (begin
                    (server-set-extensions! server '())
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'automatic)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server))))))))

                (test "automatic starttls not active and server does support starttls" (lambda () (begin
                    (server-set-extensions! server '("STARTTLS"))
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'never)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server))))))))

                (test "automatic starttls not active and server does not support starttls" (lambda () (begin
                    (server-set-extensions! server '())
                    (let 
                        ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'never)))
                        (let 
                            ((ehlo-response (smtp-ehlo connection "")))
                            (assert-response-code echo-response 220)
                            (assert (not (server-tls-started? server))))))))

                ; 'required-starttls covers modes in which starttls should always be used and the connection
                ; should be terminated in case the server does not support it
                (capability 'required-starttls (list 

                    (test "required starttls active and server supports starttls" (lambda() (begin
                        (server-set-extensions! server '("STARTTLS"))
                        (let 
                            ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'required)))
                            (let 
                                ((ehlo-response (smtp-ehlo connection "")))
                                (assert-response-code echo-response 220)
                                (assert (server-tls-started? server)))))))

                    (test "required starttls active and server does not support starttls" (lambda() (begin
                        (server-set-extensions! server '())
                        (let 
                            ((connection (smtp-connect-with-auto-starttls "localhost" (server-port server) 'required)))
                            (assert (smtp-error? connection))
                            (assert (server-tls-started? server))))))
                        
                ))
            ))

            (capability 'auth (list

                (define (connect-and-ehlo-smtp-server) 
                    (connect-smtp-server)
                    (smtp-ehlo smtp-connection ""))

                (tearDown (lambda () (begin 
                    (smtp-disconnect smtp-connection))))

                (data-test "other auth failures" 
                    '(("454 4.7.0  Temporary authentication failure" #t)
                    ("534 5.7.9  Authentication mechanism is too weak" #t)
                    ("538 5.7.11  Encryption required for requested authentication mechanism" #t)
                    ("500 5.5.6  Authentication Exchange line is too long" #t)
                    ("503 5.5.1 Error: authentication not enabled" #f) )
                    (lambda (response auth-enabled) (begin 
                        (if auth-enabled (server-set-auths! server '((PLAIN ("account" "password")))))
                        (connect-and-ehlo-smtp-server)
                        (server-set-response-code! server response)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN (list "account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)) (string-append "Expected auth failure for " response " but got " auth-result))))))
                    

                (capability 'plain-auth (list 

                    (define (plain-auth-proc credentials connection success failure)
                        (if (= credentials "AGFjY291bnQAcGFzc3dvcmQ=")
                            (success)
                            (failure)))

                    (setup (lambda () 
                        (server-set-auth-proc! server plain-auth-proc)))

                    (test "plain auth success" (lambda () (begin
                        (server-set-auths! server '((PLAIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'PLAIN (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result))))))

                    (test "plain auth unsuccessful" (lambda () (begin 
                        (server-set-auths! server '((PLAIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN '("account" "foo"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) "Expected credentials error")))))

                    (test "plain auth not supported" (lambda () (begin 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'PLAIN '("account" "foo"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result))))))

                    ))

                (capability 'xoauth2 (list 

                    (define (xoauth2-auth-proc credentials connection success failure)
                        (if (= credentials "dXNlcj1hY2NvdW50AWF1dGg9QmVhcmVyIHRva2VuAQE=")
                            (success)
                            (failure)))

                    (setup (lambda () 
                        (server-set-auth-proc! server xoauth2-auth-proc)))

                    (test "xoauth2 success" (lambda () (begin
                        (server-set-auths! server '((XOAUTH2 ("account" "token"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'XOAUTH2 (list "account" "token"))))
                            (assert (smtp-auth-successful? auth-result))))))

                    (test "xoauth2 auth unsuccessful" (lambda () (begin 
                        (server-set-auths! server '((XOAUTH2 ("account" "token"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'XOAUTH2 '("account" "not-a-token"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result))))))

                    (test "xoauth2 auth not supported" (lambda () (begin 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'XOAUTH2 '("account" "token"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result))))))

                ))

                (capability 'cram-md5 (list 

                    (define (cram-md5-auth-proc credentials connection success failure)
                        (socket-write connection "334 PDEyMzQ1Njc4OTAuMTIzNDVAc2VydmVybmFtZT4=\r\n")
                        (let 
                            ((cram-md5-response (string-trim (socket-receive connection))))
                            (if (= cram-md5-response "YWNjb3VudCAyYzBjMTgxZjkxOGU2ZGM5Mjg3Zjk3N2E1ODhiMzg1YQ==")
                                (success)
                                (failure))))

                    (setup (lambda () 
                        (server-set-auth-proc! server cram-md5-auth-proc)))

                    (test "cram-md5 success" (lambda () (begin
                        (server-set-auths! server '((CRAM-MD5 ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'CRAM-MD5 (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result))))))

                    (test "cram-md5 auth unsuccessful" (lambda () (begin 
                        (server-set-auths! server '((CRAM-MD5 ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'CRAM-MD5 '("account" "not-the-password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result))))))

                    (test "cram-md5 auth not supported" (lambda () (begin 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'CRAM-MD5 '("account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result))))))

                ))


                (capability 'login (list 

                    (define (login-auth-proc credentials connection success failure)
                        (let 
                            ((login-user-response
                                (if (not (= credentials "")) 
                                    credentials
                                    (begin
                                        (socket-write connection "334 VXNlcm5hbWU6\r\n")
                                        (string-trim (socket-receive connection))))))
                            (socket-write connection "334 UGFzc3dvcmQ6\r\n")
                            (let 
                                ((login-password-response (string-trim (socket-receive connection)))) 
                                (if (and (= login-user-response "YWNjb3VudA==") (= login-password-response "cGFzc3dvcmQ="))
                                    (success)
                                    (failure)))))

                    (setup (lambda () 
                        (server-set-auth-proc! server login-auth-proc)))

                    (test "login success" (lambda () (begin
                        (server-set-auths! server '((LOGIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result 
                                (smtp-authenticate smtp-connection 'LOGIN (list "account" "password"))))
                            (assert (smtp-auth-successful? auth-result))))))

                    (test "login auth unsuccessful" (lambda () (begin 
                        (server-set-auths! server '((LOGIN ("account" "password"))))
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'LOGIN '("account" "not-the-password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-credentials-error? auth-result) (string-append "Expected credentials error but got " auth-result))))))

                    (test "login auth not supported" (lambda () (begin 
                        (server-set-auths! server '())
                        (connect-and-ehlo-smtp-server)
                        (let 
                            ((auth-result (smtp-authenticate smtp-connection 'LOGIN '("account" "password"))))
                            (assert (not (smtp-auth-successful? auth-result)))
                            (assert (smtp-auth-not-supported-error? auth-result))))))

                ))

            ))

        ))
    )
)